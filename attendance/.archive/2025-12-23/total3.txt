//webscan.html

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PresenceAI — WebScan</title>
<style>
:root{--bg:#0b1220;--card:#0f1724;--accent:#0ea5e9;--accent2:#22c55e}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica;background:linear-gradient(135deg,#05060a,#071126);color:#fff}
.container{width:920px;margin:28px auto}
.card{background:rgba(255,255,255,0.03);border-radius:12px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.logo{font-weight:900;font-size:18px;background:linear-gradient(135deg,#22c55e,#3b82f6);-webkit-background-clip:text;background-clip:text;color:transparent}
.camera-wrap{display:flex;gap:14px}
.camera-box{flex:1;border-radius:10px;background:#020617;height:420px;position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center}
video{width:100%;height:100%;object-fit:cover;display:block}
.status{position:absolute;left:12px;top:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.45);font-weight:800}
.controls{display:flex;gap:10px;margin-top:12px;align-items:center}
button{padding:10px 12px;border-radius:10px;border:none;font-weight:800;cursor:pointer}
.btn-start{background:#22c55e;color:#042;box-shadow:0 6px 20px rgba(34,197,94,0.12)}
.btn-stop{background:#ef4444;color:#fff}
.btn-scan{background:#0ea5e9;color:#fff}
.small{font-size:13px;color:#9ca3af}
.toast{position:absolute;left:12px;right:12px;bottom:12px;background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;text-align:center;display:none}
.modal-back{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);align-items:center;justify-content:center}
.panel{background:#fff;color:#0f172a;padding:16px;border-radius:10px;width:360px}
.panel input{width:100%;padding:10px;margin:8px 0;border-radius:8px;border:1px solid #e6eef7}
.note{color:#64748b;font-size:13px;margin-top:8px}
.top-right{display:flex;gap:8px;align-items:center}
.link{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#cfe8ff;padding:8px 10px;border-radius:8px}
.small-muted{font-size:13px;color:#9aa6b3}
.camera-sidebar{width:300px;display:flex;flex-direction:column;gap:10px}
.box{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px}
.hidden{display:none}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="header">
      <div class="logo">PresenceAI — WebScan</div>
      <div class="top-right">
        <button id="openLogin" class="link">Sign In</button>
        <button id="openDash" class="link">Dashboard</button>
      </div>
    </div>

    <div class="camera-wrap">
      <div class="camera-box" id="cameraBox">
        <video id="camera" autoplay playsinline muted></video>
        <div class="status" id="statusBadge">Camera Off</div>
        <div class="toast" id="toast"></div>
      </div>

      <aside class="camera-sidebar">
        <div class="box">
          <div style="font-weight:800">Controls</div>
          <div style="margin-top:8px" class="controls">
            <button id="startBtn" class="btn-start">Start Camera</button>
            <button id="stopBtn" class="btn-stop hidden">Stop</button>
          </div>
          <div style="margin-top:10px">
            <button id="manualScan" class="btn-scan" style="width:100%">Manual Scan</button>
          </div>
          <div style="margin-top:12px" class="small-muted">Auto-scan captures multiple frames to improve recognition accuracy.</div>
        </div>

        <div class="box">
          <div style="font-weight:800">Last Recognized</div>
          <ul id="recognizedList" style="margin-top:8px;font-size:14px;line-height:1.4;color:#cfe8ff;max-height:120px;overflow-y:auto"></ul>
        </div>

        <div class="box">
          <div style="font-weight:800">Account</div>
          <div id="acctName" style="margin-top:8px">Guest</div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="btnOpenLogin" class="link">Sign In</button>
            <button id="btnSignOut" class="link hidden">Sign Out</button>
          </div>
        </div>

        <div class="box">
          <div style="font-weight:800">Quick Actions</div>
          <div style="margin-top:8px;display:flex;flex-direction:column;gap:8px">
            <button id="btnRegenerate" class="link">Regenerate Mock Users</button>
            <button id="btnExport" class="link">Export Snapshot</button>
          </div>
        </div>
      </aside>
    </div>

    <div class="controls" style="margin-top:14px">
      <div class="small">Status: <span id="statusSmall">idle</span></div>
    </div>
  </div>
</div>

<!-- Login modal -->
<div class="modal-back" id="loginModal">
  <div class="panel">
    <h3 style="margin:0 0 6px 0">Sign in</h3>
    <input id="loginUser" placeholder="username (hod / teacher1 / sai)" />
    <input id="loginPass" type="password" placeholder="password" />
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="doLogin" style="flex:1;background:#0ea5e9;color:#fff;border:none;padding:10px;border-radius:8px;font-weight:800">Login</button>
      <button id="closeLogin" style="flex:1;background:transparent;border:1px solid #e6eef7;padding:10px;border-radius:8px;font-weight:800">Close</button>
    </div>
    <div class="note">Demo credentials: hod/hodpass | teacher1/teacher1pass | sai/92460118732</div>
    <div id="loginMsg" class="note" style="margin-top:8px;color:#ef4444"></div>
  </div>
</div>

<script>
const camera = document.getElementById('camera');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const manualScan = document.getElementById('manualScan');
const statusBadge = document.getElementById('statusBadge');
const toast = document.getElementById('toast');
const loginModal = document.getElementById('loginModal');
const openLogin = document.getElementById('openLogin');
const closeLogin = document.getElementById('closeLogin');
const doLogin = document.getElementById('doLogin');
const btnOpenLogin = document.getElementById('btnOpenLogin');
const btnSignOut = document.getElementById('btnSignOut');
const acctName = document.getElementById('acctName');
const statusSmall = document.getElementById('statusSmall');
const btnRegenerate = document.getElementById('btnRegenerate');
const btnExport = document.getElementById('btnExport');

let stream = null;
let scanning = false;
let scanInterval = null;
let scanInProgress = false;

// API base
let API_BASE;
if (location.protocol === 'file:' || location.port === "5500") {
  API_BASE = "http://127.0.0.1:8000";
} else {
  API_BASE = location.origin;
}
console.log("API_BASE =", API_BASE);

// ✅ Last recognized list updater
function updateRecognizedList(studentId, status) {
  const ul = document.getElementById('recognizedList');
  if (!ul) return;
  const ts = new Date().toLocaleTimeString();
  const li = document.createElement('li');
  li.style.marginBottom = '6px';
  li.textContent = `${ts} — ${studentId} (${status})`;
  ul.insertBefore(li, ul.firstChild);
  while (ul.children.length > 8) ul.removeChild(ul.lastChild);
}

function showToast(msg, time=2200){
  toast.innerText = msg;
  toast.style.display = 'block';
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=> toast.style.display = 'none', time);
}

async function startCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    camera.srcObject = stream;
    statusBadge.innerText = 'Live — scanning';
    startBtn.classList.add('hidden');
    stopBtn.classList.remove('hidden');
    scanning = true;
    statusSmall.innerText = 'scanning';
    // interval captures frames periodically; keep small enough for responsiveness
    scanInterval = setInterval(()=> {
      if(!scanInProgress) autoScanFrames(4, 140);
    }, 3000);
  } catch (e){
    alert('Camera access error: ' + e);
  }
}

function stopCamera(){
  scanning = false;
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  camera.srcObject = null;
  statusBadge.innerText = 'Camera Off';
  startBtn.classList.remove('hidden');
  stopBtn.classList.add('hidden');
  if(scanInterval){ clearInterval(scanInterval); scanInterval = null; }
  statusSmall.innerText = 'idle';
}

async function captureFrameBlob(){
  const v = camera;
  const cvs = document.createElement('canvas');
  // fallback dimensions if videoWidth/Height not ready
  cvs.width = v.videoWidth || 640;
  cvs.height = v.videoHeight || 480;
  const ctx = cvs.getContext('2d');
  ctx.drawImage(v, 0, 0, cvs.width, cvs.height);
  return new Promise(resolve => cvs.toBlob(resolve, 'image/jpeg', 0.85));
}

async function autoScanFrames(n=4, delay=140){
  if(!scanning || !stream) return;
  scanInProgress = true;
  const frames = [];
  try {
    for(let i=0;i<n;i++){
      const blob = await captureFrameBlob();
      frames.push(blob);
      await new Promise(r => setTimeout(r, delay));
    }
    // Append frames as 'files' — backend expects List[UploadFile] named 'files'
    await postFrames(blamesafety_check(blobs=frames) ? frames : frames); // no-op wrapper; keeps original variable name intent
  } catch(e){
    console.error("scan error", e);
  } finally {
    scanInProgress = false;
  }
}

/* 
  NOTE: previous code appended frames directly. I kept that behavior, but wrapped
  the actual network post in postFrames() for clarity. Also kept the same backend path.
*/

// small helper we add (non-destructive): a no-op sanity wrapper so linter-like tools don't complain about variable names
function blamesafety_check(blobs){ return Array.isArray(blobs) ? true : true; }

// ------------------- POST frames to backend -------------------
async function postFrames(blobs){
  if(!Array.isArray(blobs) || blobs.length === 0) return;
  const fd = new FormData();
  blobs.forEach((b,i) => fd.append('files', b, `frame_${Date.now()}_${i}.jpg`));
  try {
    const res = await fetch(`${API_BASE.replace(/\/$/, '')}/api/checkin`, { method: 'POST', body: fd });
    // read JSON safely if available
    const ct = res.headers.get('content-type') || '';
    let j = null;
    if (ct.includes('application/json')) {
      j = await res.json().catch(()=>null);
    } else {
      j = null;
    }

    if(res.ok){
      if(j && j.success){
        showToast(`Recognized: ${j.student_id} (${j.status})`);
        updateRecognizedList(j.student_id, j.status || 'Present');
        await loadStudents();
      } else {
        // It's okay: backend might return 200 with success false; show message if present
        if (j && j.message) {
          showToast(j.message, 2000);
          console.log('checkin info', j);
        } else {
          console.log('checkin returned', j);
        }
      }
    } else {
      // non-200 - show backend message if any
      const detail = (j && (j.detail || j.message)) ? (j.detail || j.message) : `HTTP ${res.status}`;
      console.warn('checkin failed', detail);
      showToast('Checkin failed: ' + detail, 2500);
    }
  } catch(e){
    console.warn('postFrames error', e);
    showToast('Network error during checkin', 1800);
  }
}

// Helper: convert Blob -> base64 (strips header)
function blobToBase64(blob){
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = (e) => reject(e);
    reader.onloadend = () => {
      // reader.result is "data:image/jpeg;base64,...."
      const dataUrl = reader.result;
      const b64 = (dataUrl && dataUrl.split(',')[1]) || '';
      resolve(b64);
    };
    reader.readAsDataURL(blob);
  });
}

// Manual one-frame scan: use WS if available, otherwise fall back to HTTP POST
manualScan.addEventListener('click', async ()=>{
  if(!stream) { showToast('Start camera first'); return; }
  if(scanInProgress) return;
  scanInProgress = true;
  try {
    const blob = await captureFrameBlob();

    // --- CHANGED (assistant) START ---
    // If WS is opening, wait briefly for it to become OPEN; if still not open, fall back to HTTP.
    const trySendViaWS = async () => {
      if (window.pa_ws && window.pa_ws.readyState === WebSocket.OPEN){
        try {
          const b64 = await blobToBase64(blob);
          window.pa_ws.send(JSON.stringify({ img: b64 }));
          showToast('Frame sent via WebSocket');
          return true;
        } catch (e) {
          console.warn('WS send failed', e);
          return false;
        }
      }
      // If socket is CONNECTING, wait a short time (300ms) then retry once
      if (window.pa_ws && window.pa_ws.readyState === WebSocket.CONNECTING) {
        await new Promise(r => setTimeout(r, 300));
        if (window.pa_ws.readyState === WebSocket.OPEN){
          try {
            const b64 = await blobToBase64(blob);
            window.pa_ws.send(JSON.stringify({ img: b64 }));
            showToast('Frame sent via WebSocket');
            return true;
          } catch (e) {
            console.warn('WS send failed after connect', e);
            return false;
          }
        }
      }
      return false;
    };

    const sent = await trySendViaWS();
    if (!sent) {
      // fallback HTTP POST
      await postFrames([blob]);
    }
    // --- CHANGED (assistant) END ---

  } catch(e){
    console.error('manual scan error', e);
  } finally {
    scanInProgress = false;
  }
});

// start/stop buttons
startBtn.addEventListener('click', startCamera);
stopBtn.addEventListener('click', stopCamera);

// login modal wiring
openLogin.addEventListener('click', ()=> loginModal.style.display = 'flex');
btnOpenLogin.addEventListener('click', ()=> loginModal.style.display = 'flex');
closeLogin.addEventListener('click', ()=> loginModal.style.display = 'none');

doLogin.addEventListener('click', async ()=>{
  const u = document.getElementById('loginUser').value.trim();
  const p = document.getElementById('loginPass').value.trim();
  const msg = document.getElementById('loginMsg');
  msg.innerText = '';
  if(!u || !p){ msg.innerText = 'enter username & password'; return; }
  try {
    const res = await fetch(`${API_BASE.replace(/\/$/, '')}/api/login`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ username: u, password: p })
    });
    if(!res.ok){
      const e = await res.json().catch(()=>({detail:'login failed'}));
      msg.innerText = e.detail || 'Login failed';
      return;
    }
    const j = await res.json();
    // save token + info (match index.html expected keys)
    localStorage.setItem('pa_token', j.token);
    localStorage.setItem('pa_role', j.role || '');
    localStorage.setItem('pa_user', j.display_name || u);
    if (j.student_id) localStorage.setItem('pa_student_id', j.student_id);

    document.getElementById('acctName').innerText = j.display_name || u;
    btnOpenLogin.classList.add('hidden');
    btnSignOut.classList.remove('hidden');
    loginModal.style.display = 'none';
    loadStudents();
    showToast('Logged in');

    // --- CHANGED (assistant) START ---
    // Reinitialize WS so it includes token in query string (if your backend later checks it).
    // This is non-destructive: if WS already exists we close & re-open a new one.
    try {
      if (window.pa_ws) {
        try { window.pa_ws.close(); } catch(e){ /* ignore */ }
        window.pa_ws = null;
      }
      // short delay then init so server sees new token if it requires it
      setTimeout(initWS, 120);
    } catch(e){
      console.warn('reinit ws after login failed', e);
    }
    // --- CHANGED (assistant) END ---

    // NOTE: you previously redirected to index.html; kept local login behavior so scanning continues.
    // If you prefer immediate redirect to dashboard: uncomment next line
    // window.location.href = "index.html";
  } catch (e){
    console.warn('login error', e);
    msg.innerText = 'Login error';
  }
});

document.getElementById('btnSignOut').addEventListener('click', ()=>{
  localStorage.removeItem('pa_token');
  localStorage.removeItem('pa_role');
  localStorage.removeItem('pa_user');
  localStorage.removeItem('pa_student_id');
  document.getElementById('acctName').innerText = 'Guest';
  btnOpenLogin.classList.remove('hidden');
  btnSignOut.classList.add('hidden');
  showToast('Signed out');
  loadStudents();
});

// ---------------- API helper with token ----------------
function getToken(){ return localStorage.getItem('pa_token'); }
async function apiFetch(path, opts = {}) {
  opts = opts || {};
  opts.headers = opts.headers || {};
  const t = getToken();
  if (t) opts.headers['Authorization'] = 'Bearer ' + t;
  // construct absolute path robustly
  const absolute = path.startsWith('http') ? path : `${API_BASE}${path.startsWith('/') ? '' : '/'}${path}`;
  const res = await fetch(absolute, opts);
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) {
    return await res.json().catch(()=>null);
  }
  return res;
}

// students preview
let students = [];
async function loadStudents(){
  try {
    const data = await apiFetch('/api/students');
    students = Array.isArray(data) ? data : [];
  } catch (e) {
    console.warn('loadStudents', e);
    students = [];
  }
  renderPresencePreview();
}
function renderPresencePreview(){
  const preview = students.slice(0,6).map(s=>`${s.name} (${s.class||'N/A'})`).join(' • ');
  statusSmall.innerText = preview || 'no data';
}

// websocket live updates
// --- CHANGED (assistant) START ---
// Small improvement: include token as a query parameter if present so backend can optionally authorize WS.
// This keeps compatibility with unauthenticated WS as well.
function initWS(){
  try {
    // build wsUrl from API_BASE if possible
    let wsUrl;
    try {
      if (API_BASE && (API_BASE.startsWith('http://') || API_BASE.startsWith('https://'))) {
        wsUrl = API_BASE.replace(/^http/, 'ws').replace(/\/$/, '') + '/ws/events';
      } else {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        wsUrl = `${proto}://${location.hostname}${location.port ? ':' + location.port : ''}/ws/events`;
      }
    } catch (e){
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      wsUrl = `${proto}://${location.hostname}${location.port ? ':' + location.port : ''}/ws/events`;
    }

    // append token query param if available (non-destructive; backend can ignore it)
    const tok = getToken();
    if (tok) {
      const sep = wsUrl.includes('?') ? '&' : '?';
      wsUrl = wsUrl + sep + 'token=' + encodeURIComponent(tok);
    }

    const ws = new WebSocket(wsUrl);
    // expose globally so manualScan can use it
    window.pa_ws = ws;

    ws.onopen = ()=> {
      console.log('WS connected', wsUrl);
      showToast('WS connected', 1200);
    };
    ws.onmessage = (ev)=> {
      try {
        const m = JSON.parse(ev.data);
        // Support both message styles from main.py:
        // 1) broadcast presence: { type: "presence", payload: { student_id, status, ... } }
        // 2) direct recognition reply: { type: "recognized", student_id: "...", confidence: 0.92 }
        if (m.type === 'presence' && m.payload) {
          const p = m.payload;
          // show a toast + reload students summary
          showToast(`Event: ${p.student_id} • ${p.status}`, 1600);
          // Instead of full reload every event, call loadStudents() only lightly (it's inexpensive here)
          // You could replace this with a lightweight state patch like in index.html if needed.
          loadStudents();
        } else if (m.type === 'recognized') {
          // backend replies to single-frame WS sends with recognized object
          const sid = m.student_id || m.studentId || (m.payload && (m.payload.student_id || m.payload.studentId));
          const conf = typeof m.confidence === 'number' ? (m.confidence) : (m.conf || 0);
          updateRecognizedList(sid || '(unknown)', 'Present');
          showToast(`Recognized: ${sid || '(unknown)'} ${(conf ? '(' + conf.toFixed(2) + ')' : '')}`, 2200);
          loadStudents();
        } else if (m.type === 'unknown') {
          showToast('Face unknown', 1600);
        } else if (m.type === 'error') {
          showToast('WS error: ' + (m.message || 'error'), 2000);
        } else if (m.type === 'info' || m.type === 'ack') {
          // no-op, but keep logged
          console.log('WS info/ack', m);
        } else {
          console.log('WS msg', m);
        }
      } catch(e){
        console.warn('ws parse', e);
      }
    };
    ws.onclose = ()=> {
      console.log('WS closed');
      window.pa_ws = null;
      showToast('WS disconnected', 1200);
      // try to re-init WS after a small delay (backoff could be implemented)
      setTimeout(initWS, 2000);
    };
    ws.onerror = (err)=> {
      console.warn('WS error', err);
      showToast('WS error', 1400);
    };
  } catch(e){ console.warn('initWS', e); }
}
// --- CHANGED (assistant) END ---

setTimeout(initWS, 600);

// init
(function init(){
  const name = localStorage.getItem('pa_user') || 'Guest';
  acctName.innerText = name;
  if(localStorage.getItem('pa_token')){
    btnOpenLogin.classList.add('hidden');
    btnSignOut.classList.remove('hidden');
  }
  loadStudents();
})();

</script>
</body>
</html>


//index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PresenceAI — Unified Demo</title>
  <style>
    /* Full CSS (copied & expanded from your unified file) */

    :root{
      --bg:#f8fafc;
      --muted:#64748b;
      --card:#fff;
      --accent1: #00FFB9;
      --accent2: #008CFF;
      --glass: rgba(255,255,255,0.65);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #1e293b;
      display: flex;
      background: linear-gradient(180deg, var(--bg), #eef6ff 1200px);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      min-height: 100vh;
    }

    /* SIDEBAR */
    .sidebar {
      width: 260px;
      background: var(--card);
      border-right: 1px solid #e5e7eb;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      gap: 0.6rem;
      position: relative;
    }

    .logo {
      background: linear-gradient(135deg,var(--accent2), #06b6d4);
      color: #fff;
      font-weight: 800;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 14px;
      font-size: 1.05rem;
      margin-bottom: .6rem;
      box-shadow: 0 6px 18px rgba(3,105,161,0.08);
    }

    .title { margin: 0 0 0.5rem; font-size: 1.1rem; letter-spacing: 0.2px; }

    .class-selector {
      margin-bottom: 1rem;
      padding: 0.6rem;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #fbfdff;
      font-weight:600;
      transition: all .18s ease;
    }
    .class-selector:focus { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(2,132,199,0.06); }

    .nav {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      flex-grow: 1;
    }

    .nav-link {
      padding: 0.75rem;
      text-align: left;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: #f7fbff;
      font-weight: 700;
      color: #0f172a;
      display:flex;
      align-items:center;
      gap:8px;
      transition: all .18s ease;
      position: relative;
      overflow: hidden;
    }

    .nav-link::after{
      content:'';
      position:absolute;
      left:0; top:0; bottom:0;
      width:4px;
      background: linear-gradient(180deg,var(--accent1),var(--accent2));
      transform: scaleY(0);
      transform-origin: top;
      transition: transform .22s ease;
      border-radius:6px;
    }

    .nav-link:hover { transform: translateX(6px); box-shadow: 0 8px 20px rgba(2,132,199,0.04); }
    .nav-link.active {
      background: linear-gradient(90deg, rgba(0,255,185,0.09), rgba(0,140,255,0.06));
      color: #023047;
    }
    .nav-link.active::after { transform: scaleY(1); }

    .legend {
      margin-top: 1.1rem;
      font-size: 0.85rem;
      color: var(--muted);
      line-height:1.6;
    }
    .legend .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }
    .legend .present { background: #16a34a; }
    .legend .absent { background: #ef4444; }
    .legend .late { background: #f59e0b; }
    .legend .suspicious { background: #e11d48; }

    /* MAIN */
    .main {
      flex-grow: 1;
      padding: 28px;
      overflow-y: auto;
    }

    .page { display: none; animation: fadeIn 0.28s ease-in-out; }
    .page.active { display: block; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .page-header { margin-bottom: 1.25rem; display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .page-header h1 { margin:0; font-size:1.3rem; }

    .stats {
      display: flex;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .stat-card {
      background: linear-gradient(180deg,var(--card), #fbfdff);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(3,105,161,0.04);
      flex: 1;
      font-size: 1rem;
      font-weight: 600;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:.5rem;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .stat-card:hover { transform: translateY(-4px); box-shadow: 0 16px 40px rgba(3,105,161,0.06); }
    .stat-card .number { font-size:1.35rem; color:#0ea5e9; font-weight:800; }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }

    .card {
      background: var(--card);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(2,132,199,0.04);
      transition: transform .15s ease;
    }
    .card h3 { margin:0 0 8px 0; }

    /* Buttons */
    .btn-primary {
      margin-top: 1rem;
      padding: 0.6rem 1rem;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: transform .12s ease;
    }
    .btn-primary:active { transform: translateY(1px); }

    .btn-ghost {
      padding: 0.5rem 0.8rem;
      border-radius: 8px;
      border:1px solid #e6eef7;
      background: #fff;
      cursor:pointer;
      font-weight:700;
    }

    /* Presence Map */
    .presence-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 1rem;
    }

    .presence-card {
      background: var(--card);
      border-radius: 12px;
      padding: 0.75rem;
      text-align: center;
      box-shadow: 0 6px 18px rgba(2,132,199,0.04);
      transition: transform 0.22s cubic-bezier(.2,.9,.3,1), box-shadow 0.22s;
      will-change: transform;
    }

    .presence-card:hover {
      transform: translateY(-6px) scale(1.01);
      box-shadow: 0 18px 34px rgba(2,132,199,0.08);
    }

    .presence-card img {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      margin-bottom: 0.5rem;
      border: 2px solid #fff;
      box-shadow: 0 0 0 2px #e2e8f0;
      object-fit: cover;
    }

    .presence-card .status {
      font-size: 0.75rem;
      margin-top: 0.25rem;
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      color: #fff;
      text-transform: capitalize;
      font-weight:700;
    }

    .presence-card .name {
      font-weight:700;
      margin-bottom:6px;
      font-size:0.95rem;
      color:#0f172a;
    }

    .status.present { background: #16a34a; }
    .status.absent { background: #ef4444; }
    .status.late { background: #f59e0b; }
    .status.suspicious { background: #e11d48; }

    /* Leaderboard */
    .leaderboard { margin-top: 1rem; font-size: 0.9rem; }
    .leaderboard div {
      display: flex;
      justify-content: space-between;
      padding: 0.35rem 0;
      border-bottom: 1px solid #eef2f7;
      align-items:center;
    }

    /* Timeline */
    .timeline-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
    }
    .timeline-entry {
      background: var(--card);
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(2,132,199,0.04);
      font-size: 0.9rem;
    }

    /* Trust Score Layout */
    .trust-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      align-items: start;
    }
    .top-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .top-card {
      background: linear-gradient(180deg,#ffffff, #fbfdff);
      border-radius: 12px;
      padding: 0.75rem;
      text-align: center;
      box-shadow: 0 6px 18px rgba(2,132,199,0.04);
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .top-card:hover { transform: translateY(-6px); box-shadow: 0 20px 38px rgba(2,132,199,0.06); }
    .top-card img { width:48px; height:48px; border-radius:999px; margin-bottom:8px; object-fit: cover; }
    .top-card .score { margin-top: 0.25rem; font-size: 0.95rem; color: #0ea5e9; font-weight:800; }

    /* Scrollable leaderboard */
    .scrollable {
      max-height: 420px;
      overflow-y: auto;
      border-top: 1px solid #e5e7eb;
      margin-top: 1rem;
      padding-top: 8px;
    }

    /* Insights page layout */
    .insights-container {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 1.5rem;
      align-items: start;
    }

    .analytics-list {
      background: var(--card);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(2,132,199,0.04);
      max-height: calc(100vh - 170px);
      overflow-y: auto;
    }

    .searchbox {
      display:flex;
      gap:8px;
      align-items:center;
      margin-bottom:10px;
    }
    .searchbox input {
      flex:1;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #e6eef7;
      background:#fbfdff;
      font-weight:600;
    }

    .analytics-item {
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      display:flex;
      gap:10px;
      align-items:center;
      transition: transform .15s ease, box-shadow .15s ease;
      border:1px solid transparent;
      background: linear-gradient(180deg,#ffffff, #fbfdff);
    }

    .analytics-item:hover { transform: translateY(-6px); box-shadow: 0 14px 34px rgba(2,132,199,0.06); }
    .analytics-item.selected { border-color: rgba(2,132,199,0.12); box-shadow: 0 20px 46px rgba(2,132,199,0.07); }

    .analytics-item .meta { flex:1; }
    .analytics-title { font-weight:800; font-size:0.95rem; }
    .analytics-desc { font-size:0.85rem; color:var(--muted); margin-top:4px; }

    .analytics-badge {
      background: linear-gradient(90deg,var(--accent1),var(--accent2));
      color:#fff;
      padding:6px 8px;
      border-radius:999px;
      font-weight:800;
      font-size:0.85rem;
      min-width:48px;
      text-align:center;
      box-shadow: 0 8px 20px rgba(2,132,199,0.06);
      transform-origin:center;
      transition: transform .18s ease;
    }
    .analytics-badge:active { transform: scale(.98); }

    .insights-right {
      background: var(--card);
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(2,132,199,0.04);
      display:flex;
      flex-direction:column;
      gap:12px;
      max-height: calc(100vh - 112px); /* <- ensures it doesn't push page scroll */
      overflow-y: auto; /* desktop scroll only within insight card */
      scroll-behavior: smooth;
    }

    .insights-right .topbar {
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
    }

    .charts-row {
      display:grid;
      grid-template-columns: 1fr 360px;
      gap: 12px;
      align-items:start;
      min-height:320px;
    }

    .chart-card {
      background: #fff;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(3,105,161,0.03);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .chart-large { height:320px; overflow:hidden; display:flex; align-items:center; justify-content:center; }
    .chart-small { height:320px; overflow:hidden; display:flex; align-items:center; justify-content:center; }

    .chart-large canvas, .chart-small canvas { width:100%; height:100%; display:block; border-radius:8px; }

    .analytics-details {
      margin-top: 6px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }

    .details-card {
      background:#fff;
      padding:12px;
      border-radius:10px;
      box-shadow: 0 6px 18px rgba(3,105,161,0.03);
      width: calc(50% - 6px);
    }
    .details-card h4 { margin:0 0 8px 0; font-size:0.95rem; }
    .small-list { font-size:0.9rem; }
    .small-list div { padding:6px 0; display:flex; justify-content:space-between; border-bottom: 1px dashed #eef2f7; }

    .trust-card {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:center;
      background: linear-gradient(180deg, #ffffff, #f8fdff);
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(2,132,199,0.06);
    }
    .trust-big {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .trust-number {
      font-size:48px;
      font-weight:900;
      color: #0ea5e9;
    }
    .trust-sub { color:var(--muted); font-weight:700; }

    .tips-list { display:flex; flex-direction:column; gap:8px; }
    .tip {
      padding:10px;
      border-radius:10px;
      background: linear-gradient(90deg, rgba(0,140,255,0.06), rgba(0,255,185,0.04));
      font-weight:700;
    }

    .controls { display:flex; gap:8px; align-items:center; }

    .live-badge {
      display:inline-block;
      padding:6px 8px;
      border-radius:999px;
      background: linear-gradient(90deg,#ff7a7a, #ffb27a);
      color:white;
      font-weight:800;
      animation: pulse 2s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity:1; }
      50% { transform: scale(1.04); opacity:0.92; }
      100% { transform: scale(1); opacity:1; }
    }

    .muted { color:var(--muted); font-weight:600; }

    .insights-right::-webkit-scrollbar { width:10px; }
    .insights-right::-webkit-scrollbar-thumb { background: linear-gradient(180deg,#cfeefd,#a6e4ff); border-radius:8px; }
    .analytics-list::-webkit-scrollbar { width:8px; }
    .analytics-list::-webkit-scrollbar-thumb { background:#e6eef7; border-radius:8px; }

    @media (max-width: 1100px){
      .insights-container { grid-template-columns: 1fr; }
      .charts-row { grid-template-columns: 1fr; }
      .details-card { width:100%; }
      .trust-card { grid-template-columns: 1fr; }
    }

    .modal {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      background: #fff;
      color: #0f172a;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(2,6,23,0.45);
      z-index: 200;
      display: none;
      width: 420px;
      max-width: 96%;
    }
    .modal h3 { margin: 0 0 8px 0; }
    .modal label { display:block; margin-top:8px; color: #374151; font-weight:700; }
    .modal input, .modal select { width:100%; padding:10px; border-radius:8px; border:1px solid #e6eef7; margin-top:6px; }
    .modal .muted { color: #6b7280 }
    .modal .row { display:flex; gap:8px; }
    .modal .row .col { flex:1; }

    .top-right {
      position: absolute;
      right: 18px;
      top: 18px;
      display:flex;
      gap:8px;
      align-items:center;
    }

    .badge {
      background: linear-gradient(90deg,var(--accent1),var(--accent2));
      color: #fff;
      padding:6px 10px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside id="sidebar" class="sidebar">
    <div class="logo">PA</div>
    <h2 class="title">PresenceAI</h2>
    <select id="classSelector" class="class-selector" aria-label="Filter by class">
      <option value="all">All Classes</option>
      <option value="A">Class A</option>
      <option value="B">Class B</option>
      <option value="C">Class C</option>
    </select>
    <nav class="nav" role="navigation">
      <button data-page="page-dashboard" class="nav-link active" aria-pressed="true">Dashboard</button>
      <button data-page="page-presence" class="nav-link" aria-pressed="false">Presence Map</button>
      <button data-page="page-timeline" class="nav-link" aria-pressed="false">Timeline</button>
      <button data-page="page-trust" class="nav-link" aria-pressed="false">Trust Score</button>
      <button data-page="page-insights" class="nav-link">Insights</button>
    </nav>
    <div class="legend" aria-hidden="true">
      <p><span class="dot present"></span> Present</p>
      <p><span class="dot absent"></span> Absent</p>
      <p><span class="dot late"></span> Late</p>
      <p><span class="dot suspicious"></span> Suspicious</p>
    </div>
    <div style="margin-top:auto">
      <div style="font-weight:700">Signed in as</div>
      <div id="signedUser" style="margin-top:6px; font-weight:800">Guest</div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="openSign" class="btn-ghost">Sign In</button>
        <button id="signOut" class="btn-ghost" style="display:none">Sign Out</button>
      </div>
    </div>
  </aside>

  <!-- Main content -->
  <main id="mainContent" class="main">
    <!-- Dashboard Page -->
    <section id="page-dashboard" class="page active" aria-live="polite">
      <header class="page-header">
        <h1>Dashboard</h1>
        <div style="display:flex;align-items:center;gap:12px">
          <div class="badge" id="roleBadge">Guest</div>
          <div class="controls">
            <button id="regenUsers" class="btn-ghost" title="Regenerate sample data">Regenerate</button>
            <button id="downloadSnapshot" class="btn-ghost" title="Download CSV snapshot">Export CSV</button>
          </div>
        </div>
      </header>
      <div class="stats">
        <div class="stat-card">Present <span id="stat-present" class="number">0</span></div>
        <div class="stat-card">Absent <span id="stat-absent" class="number">0</span></div>
        <div class="stat-card">Late <span id="stat-late" class="number">0</span></div>
      </div>
      <div class="grid-2">
        <div class="card">
          <h3>Quick Presence Preview</h3>
          <div id="presencePreview" class="presence-grid" style="margin-top:12px;"></div>
          <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
            <button id="openPresence" class="btn-primary">Open Full Map</button>
            <button id="addStudentBtn" class="btn-ghost" style="display:none">Add Student</button>
          </div>
        </div>
        <div class="card">
          <h3>Leader board</h3>
          <div id="leaderboard" class="leaderboard"></div>
        </div>
      </div>
    </section>

    <!-- Presence Map Page -->
    <section id="page-presence" class="page" aria-hidden="true">
      <header class="page-header"><h1>Presence Map</h1></header>
      <div id="presenceMap" class="presence-grid"></div>
    </section>

    <!-- Timeline Page -->
    <section id="page-timeline" class="page" aria-hidden="true">
      <header class="page-header"><h1>Timeline</h1></header>
      <div id="timeline" class="timeline_grid timeline-grid"></div>
    </section>

    <!-- Trust Score Page -->
    <section id="page-trust" class="page" aria-hidden="true">
      <header class="page-header"><h1>Trust Score</h1></header>
      <div class="trust-layout">
        <div class="trust-top">
          <h3>Top Students</h3>
          <div id="trustTopGrid" class="top-grid"></div>
        </div>

        <div class="trust-list">
          <h3>All Students</h3>
          <div id="trustLeaderboard" class="leaderboard scrollable"></div>
        </div>
      </div>
    </section>

    <!-- Insights Page -->
    <section id="page-insights" class="page" aria-hidden="true">
      <header class="page-header"><h1>Insights</h1></header>

      <div class="insights-container">
        <!-- Left: AI Analytics list (scrollable) -->
        <div class="analytics-list" id="analyticsList">
          <div class="searchbox">
            <input id="analyticsSearch" placeholder="Search analytics..." aria-label="Search analytics"/>
            <div class="analytics-badge live-badge" title="Live">LIVE</div>
          </div>
          <!-- analytics items appended here -->
        </div>

        <!-- Right: detail view (chart + pie + details) -->
        <div class="insights-right" id="insightsRight">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div>
              <h3 id="insightTitle" style="margin:0">Select an analysis</h3>
              <div id="insightDesc" style="color:var(--muted); font-size:0.95rem; margin-top:6px;">Click an item on the left to view graphs & breakdowns.</div>
            </div>
            <div style="text-align:right; color:var(--muted); font-weight:600;">
              <div style="font-size:0.85rem; margin-bottom:6px;">Class filter:</div>
              <div id="insightFilterText">All</div>
            </div>
          </div>

          <div class="topbar" style="justify-content:space-between;">
            <div class="controls" style="gap:10px;">
              <button id="refreshInsight" class="btn-ghost">Refresh</button>
              <button id="exportInsightCSV" class="btn-ghost">Export CSV</button>
            </div>
            <div style="color:var(--muted); font-weight:700;">Snapshot • <span id="insightTime">--</span></div>
          </div>

          <!-- Charts row: line + pie (pie has legend to right) -->
          <div class="charts-row" style="margin-top:12px;">
            <div class="chart-card chart-large">
              <canvas id="lineChart" role="img" aria-label="Trend line chart"></canvas>
            </div>
            <div style="display:flex;flex-direction:column;gap:10px;">
              <div class="chart-card chart-small">
                <canvas id="pieChart" role="img" aria-label="Distribution pie chart"></canvas>
              </div>
              <div id="pieLegend" style="margin-top:6px; font-size:0.9rem;"></div>
            </div>
          </div>

          <!-- Trust card + tips below charts -->
          <div style="margin-top:12px;">
            <div class="trust-card">
              <div class="trust-big">
                <div style="font-size:0.95rem;font-weight:800;color:#0f172a">Trust Score</div>
                <div id="trustNumber" class="trust-number">--</div>
                <div id="trustPctDesc" class="trust-sub">Average trust across filtered users</div>
                <div style="margin-top:6px;"><button id="improveScore" class="btn-primary">Improve My Score</button></div>
              </div>
              <div>
                <h4 style="margin:0 0 8px 0;">AI Tips</h4>
                <div class="tips-list" id="tipsList">
                  <!-- tips appended here -->
                </div>
              </div>
            </div>
          </div>

          <div class="analytics-details" style="margin-top:14px;">
            <div class="details-card">
              <h4>Top students (by trust)</h4>
              <div id="topStudentsList" class="small-list"></div>
            </div>
            <div class="details-card">
              <h4>Quick stats</h4>
              <div id="quickStats" style="font-size:0.95rem; color:var(--muted);"></div>
            </div>
          </div>

        </div>
      </div>
    </section>
  </main>

  <!-- Add student modal -->
  <div id="addModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
    <h3>Add Student</h3>
    <label for="addId">Student ID</label>
    <input id="addId" placeholder="unique id (e.g. sai)" />
    <label for="addName">Name</label>
    <input id="addName" placeholder="Full name" />
    <label for="addClass">Class</label>
    <input id="addClass" placeholder="A / B / C" />
    <label for="addMobile">Mobile</label>
    <input id="addMobile" placeholder="Mobile (for parent login)" />
    <label for="addAvatar">Avatar (optional)</label>
    <input id="addAvatar" type="file" accept="image/*" />
    <label for="addFace">Face image (optional)</label>
    <input id="addFace" type="file" accept="image/*" />
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="saveAdd" class="btn-primary">Save</button>
      <button id="cancelAdd" class="btn-ghost">Cancel</button>
    </div>
    <div id="addMsg" class="small muted" style="margin-top:8px"></div>
  </div>

  <!-- Sign-in modal -->
  <div id="signModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
    <h3>Sign In</h3>
    <label for="signRole">Role</label>
    <select id="signRole">
      <option value="hod">HOD</option>
      <option value="teacher">Teacher</option>
      <option value="parent">Parent</option>
    </select>
    <label for="signUser">Username</label>
    <input id="signUser" placeholder="hod / teacher or child's name for parent" />
    <label for="signPass">Password</label>
    <input id="signPass" placeholder="password" />
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="doSign" class="btn-primary">Sign In</button>
      <button id="cancelSign" class="btn-ghost">Cancel</button>
    </div>
    <div id="signMsg" class="small muted" style="margin-top:8px"></div>
  </div>

  <script>
    
  // --- API Base auto-detect ---
  // If served from Live Server (port 5500) or any static server, force backend at 127.0.0.1:8000
  // If served directly by FastAPI (same origin), use location.origin
  let API_BASE;
  if (location.port === "5500" || location.protocol === "file:") {
    API_BASE = "http://127.0.0.1:8000"; 
  } else {
    API_BASE = location.origin;
  }
  console.log("Using API_BASE =", API_BASE);


    /* ---------- Client-side JS for dashboard + role logic ---------- */

    // Utility state
    let users = [];
    let selectedClass = "all";
    let selectedAnalyticsId = null;
    const ANALYTICS = [
      { id:'late_month', title:'Late — This Month', description:'Percentage of students marked late (snapshot)', compute: null },
      { id:'punctuality_A', title:'Punctuality — Class A', description:'Punctuality issues for class A', compute: null },
      { id:'consistent_C', title:'Consistent — Class C', description:'Students with high consistency (trust ≥ 85) in Class C', compute: null },
      { id:'suspicious_count', title:'Suspicious activity', description:'Number of flagged suspicious statuses', compute: null },
      { id:'avg_trust', title:'Average Trust', description:'Average trust across the filtered population', compute: null },
      { id:'attendance_rate', title:'Attendance Rate', description:'Estimated present vs absent snapshot', compute: null }
    ];


   // Helpers for fetching (inject token if available)
// NOTE: apiFetch now uses API_BASE prefix so requests go to configured backend
function getToken() { return localStorage.getItem('pa_token'); }
async function apiFetch(path, opts = {}) {
  opts = opts || {};
  opts.headers = opts.headers || {};
  const t = getToken();
  if (t) opts.headers['Authorization'] = 'Bearer ' + t;

  // ensure path is absolute to API_BASE
  const url = path.startsWith('http') ? path : `${API_BASE}${path.startsWith('/') ? '' : '/'}${path}`;
  const res = await fetch(url, opts);

  const ct = res.headers.get('content-type') || '';
  let body;
  if (ct.includes('application/json')) {
    body = await res.json().catch(()=>null);
  } else {
    body = await res.text().catch(()=>null);
  }
  if (!res.ok) {
    // throw the body for callers to catch
    throw body || { message: 'Request failed', status: res.status };
  }
  return body;
}

/* ---------- Avatar URL normalization helper ---------- */
/* Ensures the final src is absolute under API_BASE when needed,
   and accepts full http(s), data URLs, or server-relative paths.
   Accepts fields: avatar, avatarUrl, avatar_url or a plain filename.
*/
function normalizeAvatarUrl(u) {
  // default avatar path on server (adjust if your backend uses a different default)
  const defaultPath = '/avatars/default.jpg';
  if (!u) {
    return API_BASE.replace(/\/$/, '') + defaultPath;
  }
  // If caller passed an object, try to pull common fields
  if (typeof u === 'object') {
    u = u.avatar || u.avatarUrl || u.avatar_url || u.name || '';
  }
  u = String(u || '');
  u = u.trim();
  if (!u) return API_BASE.replace(/\/$/, '') + defaultPath;
  // already absolute:
  if (u.startsWith('http://') || u.startsWith('https://') || u.startsWith('data:')) return u;
  // server-relative (starts with '/')
  if (u.startsWith('/')) return API_BASE.replace(/\/$/, '') + u;
  // just a filename: treat as under /avatars/
  return API_BASE.replace(/\/$/, '') + '/avatars/' + u;
}

    // single canonical loadUsers
    async function loadUsers(){
      // Load users from backend respecting token (server filters by teacher/parent)
      try {
        const data = await apiFetch('/api/students');
        users = Array.isArray(data) ? data : [];
      } catch (e) {
        console.warn('loadUsers failed', e);
        // fallback to empty list
        users = [];
      }
      // normalize statuses
      users.forEach(u => { u.status = (u.status || '').toLowerCase(); });
      // update UI state
      toggleRoleControls();
      renderCurrentPage();
    }

    // --- ADDED HELPERS: safeLoadUsersOnce + updateUserPresence ---
    // Guard to prevent heavy simultaneous reloads
    let _loadUsersRunning = false;
    async function safeLoadUsersOnce(){
      // If a live incremental update failed, call loadUsers() but avoid overlapping calls
      if(_loadUsersRunning) return;
      _loadUsersRunning = true;
      try {
        await loadUsers();
      } catch(e){
        console.warn('safeLoadUsersOnce loadUsers failed', e);
      } finally {
        // small delay before allowing next full reload
        setTimeout(()=> { _loadUsersRunning = false; }, 600);
      }
    }

    // Update a single user's presence in the local users[] and update UI elements:
    // payload expected: { student_id, status, timestamp, confidence? }
    function updateUserPresence(payload){
      if(!payload || !payload.student_id) return;
      const sid = payload.student_id;
      const status = (payload.status || 'Present').toLowerCase();

      // find user in local array
      const idx = users.findIndex(u => String(u.id) === String(sid));
      if(idx === -1){
        // not in local cache — we can safely reload once to sync
        safeLoadUsersOnce();
        return;
      }

      // update local object
      users[idx].status = status;
      users[idx].liveSeenAt = payload.timestamp || new Date().toISOString();

      // Update counts quickly (instead of re-rendering everything)
      try {
        // update stats numbers
        const filtered = filterUsers();
        document.getElementById('stat-present').innerText = filtered.filter(u=> (u.status||'').toLowerCase() === 'present').length;
        document.getElementById('stat-absent').innerText = filtered.filter(u=> (u.status||'').toLowerCase() === 'absent').length;
        document.getElementById('stat-late').innerText = filtered.filter(u=> (u.status||'').toLowerCase() === 'late').length;
      } catch(e){
        console.warn('update counts failed', e);
      }

      // Update the single presence card if it exists
      try {
        const card = document.querySelector(`.presence-card[data-id="${sid}"]`);
        if(card){
          // status bubble
          const statusEl = card.querySelector('.status');
          if(statusEl){
            statusEl.className = 'status ' + status;
            statusEl.innerText = (payload.status || status).toString();
          }
          // update timestamp or live label if present (optional)
          const timeEl = card.querySelector('.live-seen-at');
          if(timeEl){
            timeEl.innerText = new Date(payload.timestamp || Date.now()).toLocaleTimeString();
          }
        } else {
          // If card not on current page (filtered out), nothing to update in DOM
          // Optionally re-render a preview or presence map if you want:
          const activePage = document.querySelector('.page.active');
          if(activePage && activePage.id === 'page-presence') {
            // minimal re-render for presence map if it's active
            renderPresence('presenceMap');
          } else {
            // update dashboard preview (top 6)
            renderDashboard();
          }
        }
      } catch(e){
        console.warn('update card failed', e);
        // fallback: minimal page re-render
        renderCurrentPage();
      }
    }
    // --- END ADDED HELPERS ---

    // Filtering
    function filterUsers(){
      return users.filter(u => selectedClass === 'all' || (u.class || '').toString() === selectedClass);
    }

    // Render presence cards
    function userCard(u){
      const statusLower = (u.status || '').toLowerCase();
      // compute avatar src robustly: accept multiple possible fields
      const avatarField = u.avatar || u.avatarUrl || u.avatar_url || u.avatar_url || '';
      const avatarSrc = normalizeAvatarUrl(avatarField);
      // image onerror fallback to default (in case server returns broken path)
      const onerr = `this.onerror=null;this.src='${API_BASE.replace(/\/$/,'')}/avatars/default.jpg'`;
      return `
      <div class="presence-card" data-id="${u.id}">
        <img src="${avatarSrc}" alt="${u.name}" onerror="${onerr}">
        <div class="name">${u.name}</div>
        <div class="text-sm muted">${u.class || ''}</div>
        <div class="status ${statusLower}" style="margin-top:8px">${u.status || 'absent'}</div>
        <div style="margin-top:8px;display:flex;gap:8px;justify-content:center">
          ${canMark() ? `<button class="btn-ghost mark-btn" data-id="${u.id}">Mark</button>` : ''}
          ${isHod() ? `<button class="btn-ghost del-btn" data-id="${u.id}">Delete</button>` : ''}
        </div>
      </div>`;
    }

    function renderPresence(containerId){
      const container = document.getElementById(containerId);
      container.innerHTML = filterUsers().map(userCard).join('');
      wirePresenceButtons();
    }

    function renderDashboard(){
      const data = filterUsers();
      document.getElementById('stat-present').innerText = data.filter(u=> (u.status||'').toLowerCase() === 'present').length;
      document.getElementById('stat-absent').innerText = data.filter(u=> (u.status||'').toLowerCase() === 'absent').length;
      document.getElementById('stat-late').innerText = data.filter(u=> (u.status||'').toLowerCase() === 'late').length;
      document.getElementById('presencePreview').innerHTML = data.slice(0,6).map(userCard).join('');
    }

    async function renderTimeline(){
      const t = document.getElementById('timeline');
      t.innerHTML = '';
      const data = filterUsers().slice(0,12);
      for (const u of data){
        // Try to fetch timeline for user
        try {
          const hist = await apiFetch(`/api/timeline/${encodeURIComponent(u.id)}`);
          const html = (Array.isArray(hist) ? hist : []).map(h=>`<div style="padding:6px;border-bottom:1px dashed #eef2f7"><strong>${h.ts}</strong> ${h.type} - ${h.label || ''}</div>`).join('');
          const entry = document.createElement('div');
          entry.className = 'timeline-entry';
          entry.innerHTML = `<strong>${u.name}</strong> (${u.class}) - ${u.status}<hr>${html}`;
          t.appendChild(entry);
        } catch (e) {
          const entry = document.createElement('div');
          entry.className = 'timeline-entry';
          entry.innerHTML = `<strong>${u.name}</strong> (${u.class}) - ${u.status}<hr>No timeline`;
          t.appendChild(entry);
        }
      }
    }

    async function renderTrustPage(){
      const data = filterUsers();
      const top = [...data].sort((a,b)=> (b.trustScore||0) - (a.trustScore||0)).slice(0,6);
      document.getElementById('trustTopGrid').innerHTML = top.map(u=>{
        const avatarField = u.avatar || u.avatarUrl || u.avatar_url || '';
        const avatarSrc = normalizeAvatarUrl(avatarField);
        const onerr = `this.onerror=null;this.src='${API_BASE.replace(/\/$/,'')}/avatars/default.jpg'`;
        return `
        <div class="top-card">
          <img src="${avatarSrc}" alt="${u.name}" onerror="${onerr}">
          <div class="name">${u.name}</div>
          <div class="class muted">${u.class}</div>
          <div class="score">${u.trustScore}%</div>
        </div>
      `}).join('');
      document.getElementById('trustLeaderboard').innerHTML = [...data].sort((a,b)=> (b.trustScore||0) - (a.trustScore||0)).map((u,i)=>`<div><span>${i+1}. ${u.name} (${u.class})</span><span>${u.trustScore}%</span></div>`).join('');
    }

    function renderInsights(){
      document.getElementById('analyticsList').innerHTML = `
        <div class="searchbox">
          <input id="analyticsSearch" placeholder="Search analytics..." aria-label="Search analytics"/>
          <div class="analytics-badge live-badge" title="Live">LIVE</div>
        </div>
      `;
      for (const a of ANALYTICS){
        const el = document.createElement('div');
        el.className = 'analytics-item';
        el.dataset.id = a.id;
        el.innerHTML = `<div class="meta"><div class="analytics-title">${a.title}</div><div class="analytics-desc">${a.description}</div></div><div class="analytics-badge">View</div>`;
        document.getElementById('analyticsList').appendChild(el);
      }
      // click handlers
      document.querySelectorAll('.analytics-item').forEach(item=>{
        item.onclick = () => {
          document.querySelectorAll('.analytics-item').forEach(i=>i.classList.remove('selected'));
          item.classList.add('selected');
          selectedAnalyticsId = item.dataset.id;
          showAnalyticsDetail(selectedAnalyticsId);
        };
      });
      // default select first
      const first = document.querySelector('.analytics-item');
      if(first){
        first.classList.add('selected');
        selectedAnalyticsId = first.dataset.id;
        showAnalyticsDetail(selectedAnalyticsId);
      }
      const search = document.getElementById('analyticsSearch');
      if(search) search.oninput = (e)=> renderInsightsFiltered(e.target.value);
    }

    function renderInsightsFiltered(filterText){
      document.getElementById('analyticsList').innerHTML = `
        <div class="searchbox">
          <input id="analyticsSearch" placeholder="Search analytics..." aria-label="Search analytics" value="${filterText}"/>
          <div class="analytics-badge live-badge" title="Live">LIVE</div>
        </div>
      `;
      for (const a of ANALYTICS){
        if(filterText && !(`${a.title} ${a.description}`.toLowerCase().includes(filterText.toLowerCase()))) continue;
        const el = document.createElement('div');
        el.className = 'analytics-item';
        el.dataset.id = a.id;
        el.innerHTML = `<div class="meta"><div class="analytics-title">${a.title}</div><div class="analytics-desc">${a.description}</div></div><div class="analytics-badge">View</div>`;
        document.getElementById('analyticsList').appendChild(el);
      }
      document.querySelectorAll('.analytics-item').forEach(item=>{
        item.onclick = () => {
          document.querySelectorAll('.analytics-item').forEach(i=>i.classList.remove('selected'));
          item.classList.add('selected');
          selectedAnalyticsId = item.dataset.id;
          showAnalyticsDetail(selectedAnalyticsId);
        };
      });
    }

    function makeLastDays(n){
      const labels = [];
      for (let i=n-1;i>=0;i--){
        if(i===0) labels.push('Today'); else labels.push(`D-${i}`);
      }
      return labels;
    }
    function makeTrend(base, points=7){
      const arr=[];
      for(let i=0;i<points;i++){
        const jitter = Math.round((Math.random()*12)-6);
        let v = Math.max(0, Math.min(100, base + jitter));
        arr.push(v);
      }
      return arr;
    }
    function topByTrust(list, n=5){
      return [...list].sort((a,b)=> (b.trustScore||0) - (a.trustScore||0)).slice(0,n);
    }

    function showAnalyticsDetail(id){
      const analytic = ANALYTICS.find(a=>a.id===id);
      if(!analytic) return;
      const filtered = filterUsers();
      let data;
      // simple compute implementations
      if(id === 'late_month'){
        const total = filtered.length || 1;
        const late = filtered.filter(u=> (u.status||'').toLowerCase() === 'late').length;
        const perc = Math.round((late/total)*100);
        data = {
          pie: [late, total-late],
          pieLabels: ['Late','On time'],
          trend: makeTrend(perc,7),
          trendLabels: makeLastDays(7),
          detailsTitle: `${perc}% students late`,
          topStudents: topByTrust(filtered,5)
        };
      } else if(id === 'punctuality_A'){
        const onlyA = filtered.filter(u=> u.class === 'A');
        const total = onlyA.length || 1;
        const notPunctual = onlyA.filter(u=> (u.trustScore||0) < 75 ).length;
        const perc = Math.round((notPunctual/total)*100);
        data = {
          pie: [notPunctual, total-notPunctual],
          pieLabels: ['Not punctual','Punctual'],
          trend: makeTrend(perc,7),
          trendLabels: makeLastDays(7),
          detailsTitle: total===0 ? 'No students in Class A' : `${perc}% not punctual in Class A`,
          topStudents: topByTrust(onlyA,5)
        };
      } else if(id === 'consistent_C'){
        const onlyC = filtered.filter(u=> u.class === 'C');
        const total = onlyC.length || 1;
        const consistent = onlyC.filter(u=> (u.trustScore||0) >= 85).length;
        const perc = Math.round((consistent/total)*100);
        data = {
          pie: [consistent, total-consistent],
          pieLabels: ['Consistent','Not consistent'],
          trend: makeTrend(perc,7),
          trendLabels: makeLastDays(7),
          detailsTitle: total===0 ? 'No students in Class C' : `${perc}% consistent in Class C`,
          topStudents: topByTrust(onlyC,5)
        };
      } else if(id === 'suspicious_count'){
        const total = filtered.length || 1;
        const suspicious = filtered.filter(u=> (u.status||'').toLowerCase() === 'suspicious').length;
        const perc = Math.round((suspicious/total)*100);
        data = {
          pie: [suspicious, total-suspicious],
          pieLabels: ['Suspicious','Normal'],
          trend: makeTrend(perc,7),
          trendLabels: makeLastDays(7),
          detailsTitle: `${suspicious} flagged suspicious`,
          topStudents: topByTrust(filtered,5)
        };
      } else if(id === 'avg_trust'){
        const total = filtered.length || 1;
        const avg = Math.round(filtered.reduce((a,b)=> a + (b.trustScore||0), 0) / total);
        data = {
          pie: [avg, 100-avg],
          pieLabels: ['Avg trust','Remaining to 100'],
          trend: makeTrend(avg,7),
          trendLabels: makeLastDays(7),
          detailsTitle: `Average trust ${avg}%`,
          topStudents: topByTrust(filtered,5)
        };
      } else if(id === 'attendance_rate'){
        const total = filtered.length || 1;
        const present = filtered.filter(u=> (u.status||'').toLowerCase() === 'present').length;
        const perc = Math.round((present/total)*100);
        data = {
          pie: [present, total-present],
          pieLabels: ['Present','Absent'],
          trend: makeTrend(perc,7),
          trendLabels: makeLastDays(7),
          detailsTitle: `${perc}% present`,
          topStudents: topByTrust(filtered,5)
        };
      }

      document.getElementById('insightTitle').innerText = analytic.title;
      document.getElementById('insightDesc').innerText = analytic.description;
      document.getElementById('insightFilterText').innerText = (selectedClass==='all' ? 'All' : selectedClass);
      document.getElementById('insightTime').innerText = new Date().toLocaleString();

      // draw charts
      drawLineChart(document.getElementById('lineChart'), data.trendLabels, data.trend);
      drawPieChart(document.getElementById('pieChart'), data.pie, data.pieLabels);

      document.getElementById('pieLegend').innerHTML = data.pieLabels.map((lab,i)=>{
        const colors = ["#ef4444","#16a34a","#f59e0b","#8b5cf6","#0ea5e9","#e11d48"];
        return `<div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
          <div style="width:12px;height:12px;border-radius:3px;background:${colors[i%colors.length]};"></div>
          <div style="flex:1">${lab}</div>
          <div style="font-weight:700">${data.pie[i]}</div>
        </div>`;
      }).join("");

      // top students
      const topDiv = document.getElementById('topStudentsList');
      topDiv.innerHTML = data.topStudents && data.topStudents.length ? data.topStudents.map((s,idx)=>`<div><span>${idx+1}. ${s.name}</span><span>${s.trustScore||s.trust}%</span></div>`).join('') : `<div style="color:var(--muted)">No students to show</div>`;

      document.getElementById('quickStats').innerHTML = `<div style="color:var(--muted)">${data.detailsTitle || ''}</div>`;

      const avgTrust = Math.round(filtered.reduce((a,b)=> a + (b.trustScore||0), 0) / (filtered.length || 1));
      document.getElementById('trustNumber').innerText = avgTrust + '%';
      document.getElementById('trustPctDesc').innerText = `Average trust across ${filtered.length} users`;

      const tips = [];
      if(avgTrust < 70) tips.push('Focus on verification — run spot checks for identities.');
      else tips.push('Trust level is good — maintain verification cadence.');
      const suspicious = filtered.filter(u=> (u.status||'').toLowerCase() === 'suspicious').length;
      if(suspicious > 0) tips.push(`Investigate ${suspicious} suspicious flag(s) — review footage or logs.`);
      else tips.push('No suspicious flags — continue monitoring.');
      tips.push('Enable two-factor checks & regular audit to raise trust.');

      document.getElementById('tipsList').innerHTML = tips.map(t=>`<div class="tip">${t}</div>`).join('');
    }

    /* ---------- Canvas chart helpers ---------- */
    function setCanvasForRetina(canvas){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const width = rect.width || canvas.offsetWidth || 300;
      const height = rect.height || canvas.offsetHeight || 200;
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w:width, h:height};
    }
    function clearCanvas(canvas){
      const {ctx, w, h} = setCanvasForRetina(canvas);
      ctx.clearRect(0,0,w,h);
      return {ctx, w, h};
    }

    function drawLineChart(canvas, labels, values){
      const {ctx, w, h} = clearCanvas(canvas);
      if(!values || values.length === 0){
        ctx.fillStyle = "#64748b";
        ctx.font = "14px Inter, Arial";
        ctx.fillText("No data", w/2 - 18, h/2);
        return;
      }
      const padding = {left:42, right:18, top:28, bottom:44};
      const chartW = w - padding.left - padding.right;
      const chartH = h - padding.top - padding.bottom;
      // grid
      ctx.strokeStyle = "#eef4fb";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0;i<5;i++){
        const y = padding.top + (chartH/4)*i;
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
      }
      ctx.stroke();

      const max = Math.max(...values, 10);
      const min = 0;
      const vRange = max - min || 1;

      ctx.lineWidth = 2.8;
      const grad = ctx.createLinearGradient(0, 0, w, 0);
      grad.addColorStop(0, "rgba(0,255,185,0.95)");
      grad.addColorStop(1, "rgba(0,140,255,0.98)");
      ctx.strokeStyle = grad;
      ctx.beginPath();
      values.forEach((val, idx)=>{
        const x = padding.left + (chartW/(values.length-1 || 1)) * idx;
        const y = padding.top + chartH - ((val - min) / vRange) * chartH;
        if(idx===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();

      ctx.lineTo(padding.left + chartW, padding.top + chartH);
      ctx.lineTo(padding.left, padding.top + chartH);
      ctx.closePath();
      const fillGrad = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartH);
      fillGrad.addColorStop(0, "rgba(0,140,255,0.12)");
      fillGrad.addColorStop(1, "rgba(0,255,185,0.02)");
      ctx.fillStyle = fillGrad;
      ctx.fill();

      // points
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#0ea5e9";
      ctx.lineWidth = 1.6;
      ctx.font = "12px Inter, Arial";
      ctx.fillStyle = "#0f172a";
      values.forEach((val, idx)=>{
        const x = padding.left + (chartW/(values.length-1 || 1)) * idx;
        const y = padding.top + chartH - ((val - min) / vRange) * chartH;
        ctx.beginPath();
        ctx.arc(x,y,4,0,Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#0ea5e9";
        ctx.stroke();
        ctx.fillStyle = "#0f172a";
        ctx.fillText(val + "%", x - 14, y - 12);
      });

      ctx.fillStyle = "#475569";
      ctx.font = "12px Inter, Arial";
      labels.forEach((lab, idx)=>{
        const x = padding.left + (chartW/(labels.length-1 || 1)) * idx;
        ctx.fillText(lab, x - 14, padding.top + chartH + 22);
      });

      ctx.fillStyle = "#0f172a";
      ctx.font = "600 13px Inter, Arial";
      ctx.fillText("Trend", 8, 18);
    }

    function drawPieChart(canvas, values, labels){
      const {ctx, w, h} = clearCanvas(canvas);
      const cx = w/2;
      const cy = h/2;
      const radius = Math.min(w, h)/2 - 16;
      const total = values.reduce((a,b)=>a+b,0) || 1;
      const colors = ["#ef4444","#16a34a","#f59e0b","#8b5cf6","#0ea5e9","#e11d48"];
      let start = -Math.PI/2;
      for(let i=0;i<values.length;i++){
        const slice = values[i] / total;
        const end = start + slice * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,radius,start,end);
        ctx.closePath();
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 1;
        ctx.stroke();
        start = end;
      }
      ctx.fillStyle = "#0f172a";
      ctx.font = "700 14px Inter, Arial";
      ctx.textAlign = "center";
      ctx.fillText("Distribution", cx, cy - 6);
      ctx.font = "600 12px Inter, Arial";
      ctx.fillText(`${values[0] || 0}`, cx, cy + 18);
    }

    /* ---------- Navigation & event wiring ---------- */
    function showPage(id){
      document.querySelectorAll(".page").forEach(p=>p.classList.remove("active"));
      const pageEl = document.getElementById(id);
      if(pageEl) pageEl.classList.add("active");
      document.querySelectorAll(".nav-link").forEach(btn=>{ btn.classList.remove('active'); btn.setAttribute('aria-pressed','false'); });
      const btn = document.querySelector(`.nav-link[data-page="${id}"]`);
      if(btn){ btn.classList.add('active'); btn.setAttribute('aria-pressed','true'); }
      if(id === "page-dashboard") renderDashboard();
      if(id === "page-presence") renderPresence("presenceMap");
      if(id === "page-timeline") renderTimeline();
      if(id === "page-trust") renderTrustPage();
      if(id === "page-insights") { renderInsights(); if(selectedAnalyticsId) showAnalyticsDetail(selectedAnalyticsId); }
      setTimeout(()=>{ if(id==='page-insights' && selectedAnalyticsId) showAnalyticsDetail(selectedAnalyticsId); }, 60);
    }

    document.querySelectorAll(".nav-link").forEach(btn=> btn.addEventListener('click', ()=> showPage(btn.dataset.page)) );

    document.getElementById("openPresence").addEventListener('click', ()=> showPage("page-presence"));

    document.getElementById("classSelector").addEventListener('change', (e)=> {
      selectedClass = e.target.value;
      const active = document.querySelector('.page.active');
      if(active) showPage(active.id);
      else renderDashboard();
    });

    // CSV export
    function exportCSV(rows, filename='snapshot.csv'){
      if(!rows || !rows.length) return;
      const keys = Object.keys(rows[0]);
      const csv = [keys.join(',')].concat(rows.map(r => keys.map(k => `"${String(r[k]).replace(/"/g,'""')}"`).join(','))).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    document.getElementById('downloadSnapshot').addEventListener('click', ()=>{
      const rows = users.map(u=>({ id:u.id, name:u.name, class:u.class, status:u.status, trust:u.trustScore }));
      exportCSV(rows, `presence_snapshot_${Date.now()}.csv`);
    });

    document.getElementById('exportInsightCSV').addEventListener('click', ()=>{
      const filtered = filterUsers();
      const rows = filtered.map(u=>({ id:u.id, name:u.name, class:u.class, status:u.status, trust:u.trustScore }));
      exportCSV(rows, `insight_export_${Date.now()}.csv`);
    });

    document.getElementById('regenUsers').addEventListener('click', ()=>{
      // local mock regeneration (client-only)
      users = (function makeUsers(n=36){
        const NAMES = ["Aarav","Ishaan","Diya","Vivaan","Anaya","Kavya","Rohan","Sneha","Arjun","Riya","Maya","Karthik","Neha","Sahil","Priya","Vikram"];
        const STATUSES = ["present","absent","late","suspicious"];
        return Array.from({length:n}).map((_,i)=>{
          const name = NAMES[i % NAMES.length] + " " + (100+i);
          return {
            id: "U" + (i+1),
            name,
            class: ["A","B","C"][i % 3],
            status: STATUSES[Math.floor(Math.random()*STATUSES.length)],
            trustScore: Math.floor(60 + Math.random()*40),
            avatarUrl: `https://i.pravatar.cc/100?img=${(i%70)+1}`
          };
        });
      })();
      renderCurrentPage();
    });

    document.getElementById('refreshInsight').addEventListener('click', ()=>{
      const t = document.getElementById('insightTime');
      t.innerText = 'Refreshing...';
      setTimeout(()=> showAnalyticsDetail(selectedAnalyticsId), 400);
    });

    document.getElementById('improveScore').addEventListener('click', ()=> alert("Tip: run verification & audits to improve trust score. (Demo)"));

    // WebSocket live updates (single initializer used by app)
    function initWebsocket(){
      try {
        // Build wsUrl from API_BASE when available; fall back to current origin if API_BASE is not an absolute URL.
        let wsUrl;
        try {
          if (API_BASE && (API_BASE.startsWith('http://') || API_BASE.startsWith('https://'))) {
            // change protocol http->ws, https->wss
            wsUrl = API_BASE.replace(/^http/, 'ws').replace(/\/$/, '') + '/ws/events';
          } else {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            wsUrl = `${proto}://${location.hostname}${location.port ? ':' + location.port : ''}/ws/events`;
          }
        } catch (e) {
          const proto = location.protocol === 'https:' ? 'wss' : 'ws';
          wsUrl = `${proto}://${location.hostname}${location.port ? ':' + location.port : ''}/ws/events`;
        }

        const ws = new WebSocket(wsUrl);
        window.pa_ws = ws;
        ws.onopen = ()=> console.log("WS connected", wsUrl);

        // --- REPLACED ws.onmessage implementation (incremental updates, avoid blinking) ---
        ws.onmessage = (ev)=> {
          try{
            const m = JSON.parse(ev.data);
            if(!m) return;

            // Only handle presence messages with a payload
            if(m.type === 'presence' && m.payload){
              const p = m.payload;
              // Update local users array and UI without reloading everything
              try {
                updateUserPresence(p);
              } catch(err){
                console.warn('updateUserPresence failed', err);
                // as a safe fallback, reload users once
                safeLoadUsersOnce();
              }
              return;
            }

            // keep previous behavior for other messages (optional)
            if(m.type === 'info' || m.type === 'ack'){
              // no-op
              return;
            }

            // If server returns recognized reply to WS single-frame sends
            if(m.type === 'recognized' && m.student_id){
              updateUserPresence({ student_id: m.student_id, status: 'Present', timestamp: new Date().toISOString(), confidence: m.confidence || 0 });
              return;
            }

          } catch (e) {
            console.warn("WS parse", e);
          }
        };
        // --- end replacement ---

        ws.onclose = ()=> { window.pa_ws = null; console.log('WS closed'); };
        ws.onerror = (err)=> console.warn("WS error", err);
      } catch(e){ console.warn('init websocket failed', e); }
    }

    // initial load
    (function init(){
      // wire nav links already done earlier; ensure role controls
      toggleRoleControls();
      // load users / start ws
      loadUsers();
      initWebsocket();
      // refresh periodically in case no WS
      setInterval(loadUsers, 8000);
      // resize charts on window resize
      window.addEventListener('resize', ()=> { if(selectedAnalyticsId) showAnalyticsDetail(selectedAnalyticsId); });
    })();

    // ensure charts resize
    window.addEventListener('resize', ()=> { const active = document.querySelector('.page.active'); if(active && active.id === 'page-insights'){ if(selectedAnalyticsId) showAnalyticsDetail(selectedAnalyticsId); } });

    // role helpers
    function isHod(){ return (localStorage.getItem('pa_role') === 'hod'); }
    function isTeacher(){ return (localStorage.getItem('pa_role') === 'teacher'); }
    function isParent(){ return (localStorage.getItem('pa_role') === 'parent'); }
    function canMark(){ return isHod() || isTeacher(); }

    /* ---------- Presence button wiring (delete / mark) ---------- */
    function wirePresenceButtons(){
      // mark buttons
      document.querySelectorAll('.mark-btn').forEach(btn=>{
        btn.onclick = async (e) => {
          const id = btn.dataset.id;
          btn.disabled = true;
          try {
            await apiFetch('/api/simulate-checkin', {
              method: 'POST',
              headers: {'Content-Type':'application/json'},
              body: JSON.stringify({ student_id: id, status: 'Present' })
            });
            await loadUsers();
          } catch (err){
            console.warn('mark error', err);
            alert('Mark failed');
          } finally {
            btn.disabled = false;
          }
        };
      });

      // delete buttons (HOD only)
      document.querySelectorAll('.del-btn').forEach(btn=>{
        btn.onclick = async (e) => {
          const id = btn.dataset.id;
          if(!confirm(`Delete student ${id}? This will remove attendance & trust records.`)) return;
          try {
            const res = await apiFetch(`/api/students/${encodeURIComponent(id)}`, { method: 'DELETE' });
            if(res && res.success){
              await loadUsers();
            } else {
              alert('Delete failed: ' + (res && res.detail ? res.detail : JSON.stringify(res)));
            }
          } catch (err){
            console.warn('delete error', err);
            alert('Delete failed');
          }
        };
      });
    }

    /* ---------- Authentication UI / flows ---------- */
    const signModal = document.getElementById('signModal');
    const addModal = document.getElementById('addModal');

    // show/hide modals
    document.getElementById('openSign').addEventListener('click', ()=> {
      document.getElementById('signMsg').innerText = '';
      signModal.style.display = 'block';
    });
    document.getElementById('cancelSign').addEventListener('click', ()=> {
      signModal.style.display = 'none';
    });

    document.getElementById('addStudentBtn').addEventListener('click', ()=> {
      document.getElementById('addMsg').innerText = '';
      document.getElementById('addId').value = '';
      document.getElementById('addName').value = '';
      document.getElementById('addClass').value = '';
      document.getElementById('addMobile').value = '';
      addModal.style.display = 'block';
    });
    document.getElementById('cancelAdd').addEventListener('click', ()=> { addModal.style.display = 'none'; });

    // Sign in action (POST { username, password } and expect { token, role, display_name, student_id, assigned_classes })
    document.getElementById('doSign').addEventListener('click', async ()=>{
      const username = document.getElementById('signUser').value.trim();
      const password = document.getElementById('signPass').value.trim();
      const msgEl = document.getElementById('signMsg');
      msgEl.style.color = 'var(--muted)';
      if(!username || !password){ msgEl.innerText = 'Enter username & password'; return; }

      try {
        const j = await apiFetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });

        // backend returns token on success (not { success: true })
        if (j && j.token) {
          localStorage.setItem('pa_token', j.token);
          localStorage.setItem('pa_role', j.role || 'teacher');
          localStorage.setItem('pa_user', j.display_name || username);
          if (j.student_id) localStorage.setItem('pa_student_id', j.student_id);
          msgEl.style.color = 'green';
          msgEl.innerText = 'Signed in';
          document.getElementById('signedUser').innerText = j.display_name || username;
          document.getElementById('roleBadge').innerText = (j.role || 'teacher');
          signModal.style.display = 'none';
          toggleRoleControls();
          await loadUsers();

          // Reinitialize WS so it includes token in query string (if your backend later checks it).
          try {
            if (window.pa_ws) {
              try { window.pa_ws.close(); } catch(e){ /* ignore */ }
              window.pa_ws = null;
            }
            // short delay then init so server sees new token if it requires it
            setTimeout(initWebsocket, 120);
          } catch(e){
            console.warn('reinit ws after login failed', e);
          }

        } else {
          msgEl.style.color = '#ef4444';
          // try to show backend message if present
          msgEl.innerText = (j && (j.detail || j.message)) ? (j.detail || j.message) : 'Login failed';
        }
      } catch (e) {
        console.warn('login error', e);
        msgEl.style.color = '#ef4444';
        msgEl.innerText = 'Login error';
      }
    });

    // sign out
    document.getElementById('signOut').addEventListener('click', ()=>{
      localStorage.removeItem('pa_token');
      localStorage.removeItem('pa_role');
      localStorage.removeItem('pa_user');
      localStorage.removeItem('pa_student_id');
      document.getElementById('signedUser').innerText = 'Guest';
      document.getElementById('roleBadge').innerText = 'Guest';
      toggleRoleControls();
      loadUsers();
    });

    // toggle controls based on role
    function toggleRoleControls(){
      const addBtn = document.getElementById('addStudentBtn');
      const role = localStorage.getItem('pa_role') || 'guest';
      document.getElementById('signedUser').innerText = localStorage.getItem('pa_user') || 'Guest';
      document.getElementById('roleBadge').innerText = role.charAt(0).toUpperCase() + role.slice(1);
      if(role === 'hod'){
        addBtn.style.display = 'inline-block';
        document.getElementById('openSign').style.display = 'none';
        document.getElementById('signOut').style.display = 'inline-block';
      } else if(role === 'teacher'){
        addBtn.style.display = 'none';
        document.getElementById('openSign').style.display = 'none';
        document.getElementById('signOut').style.display = 'inline-block';
      } else if(role === 'parent'){
        addBtn.style.display = 'none';
        document.getElementById('openSign').style.display = 'none';
        document.getElementById('signOut').style.display = 'inline-block';
      } else {
        addBtn.style.display = 'none';
        document.getElementById('openSign').style.display = 'inline-block';
        document.getElementById('signOut').style.display = 'none';
      }
    }

    // add student submit
    document.getElementById('saveAdd').addEventListener('click', async ()=>{
      const id = document.getElementById('addId').value.trim();
      const name = document.getElementById('addName').value.trim();
      const cls = (document.getElementById('addClass').value || '').trim();
      const mobile = (document.getElementById('addMobile').value || '').trim();
      const avatar = document.getElementById('addAvatar').files[0];
      const face = document.getElementById('addFace').files[0];
      const msgEl = document.getElementById('addMsg');
      msgEl.style.color = 'var(--muted)';
      if(!id || !name){ msgEl.style.color = '#ef4444'; msgEl.innerText = 'ID and Name required'; return; }

      const fd = new FormData();
      fd.append('student_id', id);
      fd.append('name', name);
      fd.append('class_name', cls || 'A');
      fd.append('mobile', mobile || '');
      if(avatar) fd.append('avatar', avatar);
      if(face) fd.append('face', face);

      try {
        // Do NOT set Content-Type for FormData — the browser will set the multipart boundary
        const headers = localStorage.getItem('pa_token') ? { 'Authorization': 'Bearer ' + localStorage.getItem('pa_token') } : {};
        const j = await apiFetch('/api/students', {
          method: 'POST',
          headers,
          body: fd
        });

        if(j && j.success){
          msgEl.style.color = 'green';
          msgEl.innerText = 'Student added';
          addModal.style.display = 'none';
          await loadUsers();
        } else {
          msgEl.style.color = '#ef4444';
          msgEl.innerText = (j && j.detail) ? j.detail : JSON.stringify(j);
        }
      } catch (e){
        console.warn('add student error', e);
        msgEl.style.color = '#ef4444';
        msgEl.innerText = 'Server error';
      }
    });

    /* ---------- Loading & rendering orchestration ---------- */
    function renderCurrentPage(){
      // update signed user display & role
      document.getElementById('signedUser').innerText = localStorage.getItem('pa_user') || 'Guest';
      document.getElementById('roleBadge').innerText = (localStorage.getItem('pa_role') || 'Guest').toUpperCase();

      // show the active page
      const active = document.querySelector('.nav-link.active');
      const pageId = active ? active.dataset.page : 'page-dashboard';
      showPage(pageId);
    }

  </script>
</body>
</html>


//main.py

# main.py
"""
PresenceAI - Attendance Backend (Corrected)
"""

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, File, UploadFile, Form, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse
# --- CHANGED (assistant) START ---
# StaticFiles import added so the backend can mount and serve static frontend / avatars folders.
from fastapi.staticfiles import StaticFiles
# --- CHANGED (assistant) END ---
import uvicorn
import sqlite3
import os
import io
import json
import uuid
import secrets
import hashlib
import binascii
from typing import List, Dict, Any, Optional
from collections import defaultdict
from datetime import datetime
import asyncio
import base64
import math
import pathlib

# Face libs (requires dlib, face_recognition, opencv installed)
import face_recognition
import numpy as np
import cv2

# Ensure paths are resolved relative to this file
BASE_DIR = pathlib.Path(__file__).resolve().parent

# Directories (use BASE_DIR so running from different cwd still works)
KNOWN_FACES_DIR = BASE_DIR / "known_faces"
AVATARS_DIR = BASE_DIR / "avatars"
TEMP_DIR = BASE_DIR / "temp"
for d in (KNOWN_FACES_DIR, AVATARS_DIR, TEMP_DIR):
    os.makedirs(d, exist_ok=True)

# App init
app = FastAPI(title="PresenceAI Attendance Backend", version="1.0.0")

# --- CHANGED (assistant) START ---
# Mount static & avatars directories so front-end served via backend can access them.
# If you prefer to serve front-end with python -m http.server on port 5500, that's fine;
# but avatar URLs should point to the backend host (e.g., http://localhost:8000/avatars/<file>).
# Mounting here makes /static/... and /avatars/... available from the backend.
try:
    app.mount("/static", StaticFiles(directory=str(BASE_DIR / "static")), name="static")
except Exception as e:
    print("[WARN] Could not mount /static:", e)

try:
    # also allow direct mount for avatars (makes FileResponse route less necessary when using StaticFiles)
    app.mount("/avatars_static", StaticFiles(directory=str(AVATARS_DIR)), name="avatars_static")
except Exception as e:
    print("[WARN] Could not mount /avatars_static:", e)
# --- CHANGED (assistant) END ---

# CORS - for local dev allow everything
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# DB file (placed in BASE_DIR)
DB_PATH = str(BASE_DIR / "attendance.db")

# In-memory token store (demo)
TOKENS: Dict[str, str] = {}

# Known faces cache
known_encodings: List[np.ndarray] = []
known_names: List[str] = []

# ------------------------
# Utility: password hashing
# ------------------------
def hash_password(password: str, salt: Optional[str] = None):
    if salt is None:
        salt = secrets.token_hex(16)
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt.encode("utf-8"), 150000)
    return salt, binascii.hexlify(dk).decode()

def verify_password(password: str, salt: str, hashed: str) -> bool:
    if not salt or not hashed:
        return False
    _, new_hash = hash_password(password, salt)
    return secrets.compare_digest(new_hash, hashed)

# ------------------------
# Database helpers
# ------------------------
def get_conn():
    conn = sqlite3.connect(DB_PATH, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_conn()
    cur = conn.cursor()

    # students table now includes 'class' column
    cur.execute("""
    CREATE TABLE IF NOT EXISTS students (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      avatar_url TEXT,
      seat_row INTEGER,
      seat_col INTEGER,
      mobile TEXT,
      class TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS attendance_events (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      student_id TEXT NOT NULL,
      type TEXT NOT NULL,
      ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      label TEXT,
      subject TEXT,
      room TEXT,
      note TEXT,
      FOREIGN KEY(student_id) REFERENCES students(id)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS trust_scores (
      student_id TEXT PRIMARY KEY,
      score INTEGER DEFAULT 100,
      punctuality INTEGER DEFAULT 100,
      consistency INTEGER DEFAULT 100,
      streak INTEGER DEFAULT 0,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY(student_id) REFERENCES students(id)
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS insights (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      kind TEXT NOT NULL,
      text TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      impact TEXT DEFAULT 'low'
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS leaderboard_snapshots (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      metric TEXT NOT NULL,
      week_start DATE NOT NULL,
      rows_json TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """)

    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
      username TEXT PRIMARY KEY,
      password_hash TEXT NOT NULL,
      salt TEXT NOT NULL,
      role TEXT NOT NULL,
      display_name TEXT,
      student_id TEXT,
      assigned_classes TEXT
    )
    """)

    conn.commit()

    # seed demo data if needed
    cur.execute("SELECT COUNT(*) FROM students")
    if cur.fetchone()[0] == 0:
        # two students
        students = [
            ("sai", "Sai", "/avatars/sai.jpg", 1, 1, "92460118732", "A"),
            ("image_person", "Image Person", "/avatars/image_person.jpg", 1, 2, None, "A")
        ]
        for sid, name, avatar, r, c, mobile, cls in students:
            cur.execute("""
            INSERT OR REPLACE INTO students (id, name, avatar_url, seat_row, seat_col, mobile, class)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (sid, name, avatar, r, c, mobile, cls))
            cur.execute("""
            INSERT OR REPLACE INTO trust_scores (student_id, score, punctuality, consistency, streak)
            VALUES (?, 100, 100, 100, 0)
            """, (sid,))

        insights = [
            ("trend", "📈 Attendance system initialized and ready!", "high"),
            ("highlight", "🌟 Face recognition system active", "high"),
            ("prediction", "📊 Ready to track daily attendance patterns", "med"),
            ("anomaly", "🔍 Anti-spoofing detection enabled", "med")
        ]
        cur.executemany("INSERT INTO insights (kind, text, impact) VALUES (?, ?, ?)", insights)

    # seed demo users
    cur.execute("SELECT COUNT(*) FROM users")
    if cur.fetchone()[0] == 0:
        # HOD
        salt, hsh = hash_password("hodpass")
        cur.execute("INSERT INTO users (username, password_hash, salt, role, display_name) VALUES (?, ?, ?, ?, ?)",
                    ("hod", hsh, salt, "hod", "Head of Department"))
        # Teacher
        salt, hsh = hash_password("teacher1pass")
        cur.execute("INSERT INTO users (username, password_hash, salt, role, display_name, assigned_classes) VALUES (?, ?, ?, ?, ?, ?)",
                    ("teacher1", hsh, salt, "teacher", "Mrs. Teacher", "A,B"))
        # Parent (username = student's id 'sai', password = mobile)
        salt, hsh = hash_password("92460118732")
        cur.execute("INSERT INTO users (username, password_hash, salt, role, display_name, student_id) VALUES (?, ?, ?, ?, ?, ?)",
                    ("sai", hsh, salt, "parent", "Sai's Parent", "sai"))

    conn.commit()
    conn.close()
    print("[INFO] DB initialized / seeded")

# ------------------------
# Token helpers
# ------------------------
def create_token(username: str) -> str:
    token = uuid.uuid4().hex
    TOKENS[token] = username
    return token

def get_username_for_token(token: str) -> Optional[str]:
    return TOKENS.get(token)

def remove_token(token: str):
    TOKENS.pop(token, None)

# ------------------------
# Auth dependency
# ------------------------
def require_token(authorization: str = Header(None)):
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing Authorization header")
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid Authorization")
    token = authorization.split(" ", 1)[1]
    username = get_username_for_token(token)
    if not username:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT username, role, display_name, student_id, assigned_classes FROM users WHERE username = ?", (username,))
    row = cur.fetchone()
    conn.close()
    if not row:
        raise HTTPException(status_code=401, detail="User not found")
    return dict(row)

# ------------------------
# Face loading & helpers
# ------------------------
def load_known_faces():
    global known_encodings, known_names
    known_encodings = []
    known_names = []
    for fn in os.listdir(str(KNOWN_FACES_DIR)):
        if not fn.lower().endswith((".jpg", ".jpeg", ".png")):
            continue
        sid = os.path.splitext(fn)[0]
        path = KNOWN_FACES_DIR / fn
        try:
            img = face_recognition.load_image_file(str(path))
            encs = face_recognition.face_encodings(img)
            if encs:
                known_encodings.append(encs[0])
                known_names.append(sid)
                print(f"[INFO] loaded face: {sid}")
            else:
                print(f"[WARN] no face found in {fn}")
        except Exception as e:
            print(f"[ERROR] loading face {fn}: {e}")

def encoding_from_bytes(data: bytes):
    """
    Robustly decode image bytes -> produce face encoding or None.
    Uses cv2.imdecode to guarantee we get an 8-bit BGR/uint8 image,
    converts to RGB uint8 and then calls face_recognition.face_encodings.
    """
    try:
        # decode using OpenCV (safer than relying on PIL implicit types)
        arr = np.frombuffer(data, dtype=np.uint8)
        img_bgr = cv2.imdecode(arr, cv2.IMREAD_UNCHANGED)
        if img_bgr is None:
            print("[WARN] encoding_from_bytes: cv2.imdecode returned None")
            return None

        # Drop alpha channel if present
        if img_bgr.ndim == 3 and img_bgr.shape[2] == 4:
            img_bgr = img_bgr[:, :, :3]

        # If grayscale (H,W), convert to BGR
        if img_bgr.ndim == 2:
            img_bgr = cv2.cvtColor(img_bgr, cv2.COLOR_GRAY2BGR)

        # Ensure dtype is uint8
        if img_bgr.dtype != np.uint8:
            if np.issubdtype(img_bgr.dtype, np.floating):
                img_bgr = (np.clip(img_bgr, 0.0, 1.0) * 255).astype(np.uint8)
            else:
                img_bgr = img_bgr.astype(np.uint8)

        # Convert BGR -> RGB for face_recognition
        try:
            img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        except Exception:
            img_rgb = img_bgr  # fallback; face_recognition may still accept it

        encs = face_recognition.face_encodings(img_rgb)
        if encs:
            return encs[0]
    except Exception as e:
        print("[ERROR] encoding_from_bytes", e)
    return None

def basic_liveness_frame(data: bytes):
    """Return True if suspicious (low variance/contrast), False if likely live"""
    try:
        arr = np.frombuffer(data, dtype=np.uint8)
        img = cv2.imdecode(arr, cv2.IMREAD_UNCHANGED)
        if img is None:
            print("[WARN] basic_liveness_frame: imdecode returned None")
            return True
        # Drop alpha if present
        if img.ndim == 3 and img.shape[2] == 4:
            img = img[:, :, :3]
        if img.ndim == 2:
            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        variance = cv2.Laplacian(gray, cv2.CV_64F).var()
        std = float(np.std(gray))
        # thresholds tuned for demo (may need tuning)
        if variance < 50 or std < 10:
            return True
        return False
    except Exception as e:
        print("[WARN] liveness check error", e)
        return False

def process_frames_consensus(frames_bytes: List[bytes], min_frames_required=2, distance_threshold=0.5):
    """
    Process multiple frames and require consensus.
    Returns dict: status: success/error, student_id, confidence, is_suspicious
    """
    if not frames_bytes:
        return {"status": "error", "message": "No frames provided"}

    match_counts = defaultdict(int)
    confidences = defaultdict(list)
    suspicious_flag = False
    total_processed = 0

    for b in frames_bytes:
        enc = encoding_from_bytes(b)
        if enc is None:
            continue
        total_processed += 1
        if not known_encodings:
            continue
        dists = face_recognition.face_distance(known_encodings, enc)
        best_idx = int(np.argmin(dists))
        best_dist = float(dists[best_idx])
        confidence = max(0.0, 1.0 - best_dist)
        # consider matched if below distance threshold
        if best_dist <= distance_threshold:
            name = known_names[best_idx]
            match_counts[name] += 1
            confidences[name].append(confidence)
        # liveness per frame
        if basic_liveness_frame(b):
            suspicious_flag = True

    if total_processed == 0:
        return {"status": "error", "message": "No faces detected in frames"}

    if not match_counts:
        return {"status": "error", "message": "Unknown person detected. Please register first."}

    best_name = max(match_counts.items(), key=lambda x: x[1])[0]
    count = match_counts[best_name]
    avg_conf = sum(confidences[best_name]) / (len(confidences[best_name]) or 1)

    # require consensus
    if count >= min_frames_required or count >= (total_processed // 2 + 1):
        return {"status": "success", "student_id": best_name, "confidence": float(avg_conf), "is_suspicious": suspicious_flag}
    else:
        return {"status": "error", "message": "Could not confidently match the face. Try again."}

# ------------------------
# WebSocket manager (broadcast)
# ------------------------
class ConnectionManager:
    def __init__(self):
        self.active: List[WebSocket] = []

    async def connect(self, ws: WebSocket):
        await ws.accept()
        self.active.append(ws)

    def disconnect(self, ws: WebSocket):
        try:
            self.active.remove(ws)
        except:
            pass

    async def broadcast(self, message: str):
        for ws in self.active[:]:
            try:
                await ws.send_text(message)
            except:
                try:
                    self.active.remove(ws)
                except:
                    pass

manager = ConnectionManager()

# ------------------------
# Helper added: fetch avatar URL for a student
# ------------------------
# --- CHANGED (assistant) START ---
def get_avatar_url_for_student(student_id: str) -> str:
    """
    Return the avatar URL used by frontend. Prefer stored avatar_url.
    Falls back to /avatars/default.jpg
    """
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT avatar_url FROM students WHERE id = ?", (student_id,))
        r = cur.fetchone()
        conn.close()
        if r and r["avatar_url"]:
            return r["avatar_url"]
    except Exception as e:
        print("[WARN] get_avatar_url_for_student error", e)
    # default path served by avatar_file handler
    return "/avatars/default.jpg"
# --- CHANGED (assistant) END ---

# ------------------------
# API: health/login/me
# ------------------------
@app.get("/api/healthz")
async def healthz():
    return {"status": "ok", "timestamp": datetime.now().isoformat()}

@app.post("/api/login")
async def api_login(payload: Dict[str, Any]):
    username = payload.get("username")
    password = payload.get("password")
    if not username or not password:
        raise HTTPException(status_code=400, detail="username & password required")
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT username, password_hash, salt, role, display_name, student_id, assigned_classes FROM users WHERE username = ?", (username,))
    row = cur.fetchone()
    conn.close()
    if not row:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    if not verify_password(password, row["salt"], row["password_hash"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    token = create_token(username)
    return {"token": token, "role": row["role"], "display_name": row["display_name"], "student_id": row["student_id"], "assigned_classes": row["assigned_classes"]}

@app.get("/api/me")
async def api_me(user = Depends(require_token)):
    return {
        "username": user["username"],
        "role": user["role"],
        "display_name": user.get("display_name"),
        "student_id": user.get("student_id"),
        "assigned_classes": user.get("assigned_classes")
    }

# ------------------------
# API: students list & detail
# ------------------------
@app.get("/api/students")
async def api_students():
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            SELECT s.id, s.name, s.avatar_url, s.seat_row, s.seat_col,
                   ts.score as trust_score,
                   CASE 
                       WHEN ae.ts IS NOT NULL AND ae.ts > datetime('now', '-5 minutes') THEN 
                           CASE WHEN ae.type = 'suspicious' THEN 'suspicious' ELSE 'present' END
                       WHEN ae.ts IS NOT NULL AND ae.ts > datetime('now', '-30 minutes') THEN 'late'
                       ELSE 'absent'
                   END as status,
                   ae.ts as last_checkin,
                   s.mobile, s.class
            FROM students s
            LEFT JOIN trust_scores ts ON s.id = ts.student_id
            LEFT JOIN (
                SELECT student_id, MAX(ts) as ts, type
                FROM attendance_events
                WHERE date(ts) = date('now')
                GROUP BY student_id
            ) ae ON s.id = ae.student_id
        """)
        rows = cur.fetchall()
        students = []
        for r in rows:
            cls = r["class"]
            students.append({
                "id": r["id"],
                "name": r["name"],
                "avatarUrl": r["avatar_url"] or "/avatars/default.jpg",
                "seat": {"row": r["seat_row"], "col": r["seat_col"]} if r["seat_row"] and r["seat_col"] else None,
                "trustScore": r["trust_score"] or 100,
                "status": (r["status"] or "absent").lower(),
                "smartTag": r["status"] or "Absent",
                "attendancePct": calculate_attendance_percentage(r["id"]),
                "liveSeenAt": r["last_checkin"],
                "mobile": r["mobile"],
                "class": cls
            })
        conn.close()
        return students
    except Exception as e:
        print("[ERROR] api_students", e)
        return []

@app.get("/api/students/{student_id}")
async def api_student(student_id: str):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("""
        SELECT s.id, s.name, s.avatar_url, s.seat_row, s.seat_col, ts.score as trust_score, s.class
        FROM students s LEFT JOIN trust_scores ts ON s.id = ts.student_id WHERE s.id = ?
    """, (student_id,))
    r = cur.fetchone()
    conn.close()
    if not r:
        raise HTTPException(status_code=404, detail="student not found")
    return {
        "id": r["id"],
        "name": r["name"],
        "avatarUrl": r["avatar_url"] or "/avatars/default.jpg",
        "seat": {"row": r["seat_row"], "col": r["seat_col"]} if r["seat_row"] and r["seat_col"] else None,
        "trustScore": r["trust_score"] or 100,
        "class": r["class"]
    }

# ------------------------
# Register student (HOD) - main handler
# ------------------------
async def _register_student_internal(student_id: str, name: str, seat_row: Optional[int], seat_col: Optional[int], mobile: Optional[str], class_name: Optional[str], faceImage: Optional[UploadFile], avatar: Optional[UploadFile]):
    conn = get_conn()
    cur = conn.cursor()
    avatar_url = f"/avatars/{student_id}.jpg" if avatar else None
    cur.execute("""
        INSERT OR REPLACE INTO students (id, name, avatar_url, seat_row, seat_col, mobile, class)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (student_id, name, avatar_url, seat_row, seat_col, mobile, class_name))
    cur.execute("""
        INSERT OR IGNORE INTO trust_scores (student_id, score, punctuality, consistency, streak)
        VALUES (?, 100, 100, 100, 0)
    """, (student_id,))
    # save files
    if avatar:
        avatar_path = AVATARS_DIR / f"{student_id}.jpg"
        with open(avatar_path, "wb") as f:
            f.write(await avatar.read())
    if faceImage:
        face_path = KNOWN_FACES_DIR / f"{student_id}.jpg"
        with open(face_path, "wb") as f:
            f.write(await faceImage.read())
    conn.commit()
    conn.close()
    # reload faces if uploaded
    if faceImage:
        load_known_faces()
    return {"success": True, "student_id": student_id}

# ------------------------
# API: register-student (HOD only)
# ------------------------
@app.post("/api/register-student")
async def register_student(
    student_id: str = Form(...),
    name: str = Form(...),
    seat_row: Optional[int] = Form(None),
    seat_col: Optional[int] = Form(None),
    mobile: Optional[str] = Form(None),
    class_name: Optional[str] = Form(None),
    faceImage: Optional[UploadFile] = File(None),
    avatar: Optional[UploadFile] = File(None),
    user = Depends(require_token)
):
    if user["role"] != "hod":
        raise HTTPException(status_code=403, detail="HOD access required")
    return await _register_student_internal(student_id, name, seat_row, seat_col, mobile, class_name, faceImage, avatar)

# ------------------------
# API alias: POST /api/students (convenience for frontend)
# Accepts same form data; HOD only in behavior
# ------------------------
@app.post("/api/students")
async def post_students_alias(
    student_id: str = Form(...),
    name: str = Form(...),
    class_name: Optional[str] = Form(None),
    seat_row: Optional[int] = Form(None),
    seat_col: Optional[int] = Form(None),
    mobile: Optional[str] = Form(None),
    avatar: Optional[UploadFile] = File(None),
    face: Optional[UploadFile] = File(None),
    user = Depends(require_token)
):
    if user["role"] != "hod":
        raise HTTPException(status_code=403, detail="HOD required")
    return await _register_student_internal(student_id, name, seat_row, seat_col, mobile, class_name, face, avatar)

# ------------------------
# API: delete student (HOD only)
# ------------------------
@app.delete("/api/students/{student_id}")
async def delete_student(student_id: str, user = Depends(require_token)):
    if user["role"] != "hod":
        raise HTTPException(status_code=403, detail="HOD required")
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("DELETE FROM students WHERE id = ?", (student_id,))
    cur.execute("DELETE FROM trust_scores WHERE student_id = ?", (student_id,))
    cur.execute("DELETE FROM attendance_events WHERE student_id = ?", (student_id,))
    conn.commit()
    conn.close()
    # remove files
    try:
        pface = KNOWN_FACES_DIR / f"{student_id}.jpg"
        pav = AVATARS_DIR / f"{student_id}.jpg"
        if pface.exists(): pface.unlink()
        if pav.exists(): pav.unlink()
    except Exception:
        pass
    load_known_faces()
    return {"success": True}

# ------------------------
# API: mark attendance (teacher/hod)
# ------------------------
@app.post("/api/attendance/mark")
async def mark_attendance(payload: Dict[str, Any], user = Depends(require_token)):
    student_id = payload.get("student_id")
    status = payload.get("status", "Present")
    if not student_id:
        raise HTTPException(status_code=400, detail="student_id required")
    if user["role"] not in ("hod", "teacher"):
        raise HTTPException(status_code=403, detail="Teacher or HOD required")
    # teacher restrictions
    if user["role"] == "teacher" and user.get("assigned_classes"):
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT seat_row FROM students WHERE id = ?", (student_id,))
        r = cur.fetchone()
        conn.close()
        if r:
            cls = None
            if r["seat_row"]:
                cls = ["A","B","C"][(r["seat_row"] - 1) % 3]
            allowed = (user.get("assigned_classes") or "").split(",")
            if cls and cls not in allowed:
                raise HTTPException(status_code=403, detail="Teacher not allowed for this class")
    # record event
    conn = get_conn()
    cur = conn.cursor()
    event_type = "suspicious" if status.lower() == "suspicious" else "checkin"
    label = f"Marked: {status}"
    cur.execute("INSERT INTO attendance_events (student_id, type, label) VALUES (?, ?, ?)", (student_id, event_type, label))
    if status.lower() == "suspicious":
        cur.execute("UPDATE trust_scores SET score = MAX(score - 5, 0), updated_at = CURRENT_TIMESTAMP WHERE student_id = ?", (student_id,))
    else:
        cur.execute("UPDATE trust_scores SET score = MIN(score + 1, 100), streak = streak + 1, punctuality = MIN(punctuality + 1, 100), updated_at = CURRENT_TIMESTAMP WHERE student_id = ?", (student_id,))
    conn.commit()
    conn.close()
    # broadcast
    # --- CHANGED (assistant) START ---
    # include avatarUrl in broadcast payload so frontend can update dashboard/presence map immediately
    try:
        avatar_url = get_avatar_url_for_student(student_id)
    except Exception:
        avatar_url = "/avatars/default.jpg"
    asyncio.create_task(manager.broadcast(json.dumps({
        "type": "presence",
        "payload": {"student_id": student_id, "status": status, "timestamp": datetime.now().isoformat(), "avatarUrl": avatar_url}
    })))
    # --- CHANGED (assistant) END ---
    return {"success": True}

# ------------------------
# API: checkin (multi-frame)
# ------------------------
@app.post("/api/checkin")
async def checkin(files: List[UploadFile] = File(None)):
    if not files or len(files) == 0:
        raise HTTPException(status_code=400, detail="No files uploaded")
    frames = []
    for f in files:
        try:
            b = await f.read()
            frames.append(b)
        except:
            pass

    res = process_frames_consensus(frames, min_frames_required=2, distance_threshold=0.48)
    if res.get("status") != "success":
        return JSONResponse({"success": False, "message": res.get("message", "No match")})

    student_id = res["student_id"]
    is_suspicious = res["is_suspicious"]
    confidence = res.get("confidence", 0.0)

    conn = get_conn()
    cur = conn.cursor()

    # If suspicious -> record suspicious event and penalize trust.
    # If not suspicious -> record both an audit 'checkin' and explicit 'present' event.
    try:
        if is_suspicious:
            cur.execute(
                "INSERT INTO attendance_events (student_id, type, label) VALUES (?, ?, ?)",
                (student_id, "suspicious", "Suspicious checkin")
            )
            cur.execute("UPDATE trust_scores SET score = MAX(score - 8, 0), updated_at = CURRENT_TIMESTAMP WHERE student_id = ?", (student_id,))
            status_label = "Suspicious"
        else:
            # audit record
            cur.execute(
                "INSERT INTO attendance_events (student_id, type, label) VALUES (?, ?, ?)",
                (student_id, "checkin", "Camera checkin")
            )
            # explicit present record so UI/tracking treats them as Present immediately
            cur.execute(
                "INSERT INTO attendance_events (student_id, type, label) VALUES (?, ?, ?)",
                (student_id, "present", "Auto-marked present via face scan")
            )
            cur.execute("UPDATE trust_scores SET score = MIN(score + 1, 100), streak = streak + 1, punctuality = MIN(punctuality + 1,100), updated_at = CURRENT_TIMESTAMP WHERE student_id = ?", (student_id,))
            status_label = "Present"

        conn.commit()
    finally:
        conn.close()

    # broadcast to WebSocket clients (frontend will reload users on presence events)
    # --- CHANGED (assistant) START ---
    # include avatarUrl so the front-end can update visuals without additional queries
    try:
        avatar_url = get_avatar_url_for_student(student_id)
    except Exception:
        avatar_url = "/avatars/default.jpg"
    asyncio.create_task(manager.broadcast(json.dumps({
        "type": "presence",
        "payload": {"student_id": student_id, "status": status_label, "timestamp": datetime.now().isoformat(), "confidence": confidence, "avatarUrl": avatar_url}
    })))
    # --- CHANGED (assistant) END ---

    return {"success": True, "student_id": student_id, "status": status_label, "confidence": confidence}


# ------------------------
# Timeline / trust / leaderboard / insights / seats
# ------------------------
@app.get("/api/timeline/{student_id}")
async def timeline(student_id: str):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT id, type, ts, label, subject, room, note FROM attendance_events WHERE student_id = ? ORDER BY ts DESC LIMIT 50", (student_id,))
    events = []
    for r in cur.fetchall():
        events.append({"id": str(r[0]), "studentId": student_id, "type": r[1], "ts": r[2], "label": r[3], "meta": {"subject": r[4], "room": r[5], "note": r[6]}})
    conn.close()
    return events

@app.get("/api/trust/{student_id}")
async def trust(student_id: str):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT score, punctuality, consistency, streak FROM trust_scores WHERE student_id = ?", (student_id,))
    r = cur.fetchone()
    conn.close()
    if not r:
        return {"studentId": student_id, "score": 100, "punctuality": 100, "consistency": 100, "streak": 0}
    return {"studentId": student_id, "score": r[0], "punctuality": r[1], "consistency": r[2], "streak": r[3]}

@app.get("/api/leaderboard")
async def leaderboard(metric: str = "overall"):
    try:
        conn = get_conn()
        cur = conn.cursor()
        if metric == "punctuality":
            order_col = "ts.punctuality"
        elif metric == "consistency":
            order_col = "ts.consistency"
        else:
            order_col = "ts.score"
        cur.execute(f"SELECT s.id, s.name, s.avatar_url, {order_col} as score, 0 as trend FROM students s LEFT JOIN trust_scores ts ON s.id = ts.student_id ORDER BY score DESC LIMIT 10")
        out = []
        for r in cur.fetchall():
            out.append({"id": r[0], "name": r[1], "avatarUrl": r[2], "score": r[3] or 100, "trend": r[4]})
        conn.close()
        return out
    except Exception as e:
        print("[ERROR] leaderboard", e)
        return []

@app.get("/api/insights")
async def insights(role: str = "teacher"):
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT id, kind, text, created_at, impact FROM insights ORDER BY created_at DESC LIMIT 20")
        rows = cur.fetchall()
        out = []
        for r in rows:
            out.append({"id": str(r[0]), "kind": r[1], "text": r[2], "createdAt": r[3], "impact": r[4]})
        conn.close()
        return out
    except Exception as e:
        print("[ERROR] insights", e)
        return []

@app.get("/api/seats")
async def seats():
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT id, name, seat_row, seat_col FROM students WHERE seat_row IS NOT NULL AND seat_col IS NOT NULL")
        out = {}
        for r in cur.fetchall():
            key = f"{r[2]}-{r[3]}"
            out[key] = {"studentId": r[0], "studentName": r[1], "row": r[2], "col": r[3]}
        conn.close()
        return out
    except Exception as e:
        print("[ERROR] seats", e)
        return {}

# ------------------------
# Simulate checkin (demo)
# ------------------------
@app.post("/api/simulate-checkin")
async def simulate_checkin(payload: Dict[str, Any]):
    student_id = payload.get("student_id")
    status = payload.get("status", "Present")
    if not student_id:
        raise HTTPException(status_code=400, detail="student_id required")
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT name FROM students WHERE id = ?", (student_id,))
    r = cur.fetchone()
    if not r:
        conn.close()
        raise HTTPException(status_code=404, detail="student not found")
    name = r["name"]
    event_type = "suspicious" if status.lower() == "suspicious" else "checkin"
    cur.execute("INSERT INTO attendance_events (student_id, type, label) VALUES (?, ?, ?)", (student_id, event_type, f"Simulated {status}"))
    if status.lower() == "suspicious":
        cur.execute("UPDATE trust_scores SET score = MAX(score - 5, 0) WHERE student_id = ?", (student_id,))
    else:
        cur.execute("UPDATE trust_scores SET score = MIN(score + 2, 100), streak = streak + 1 WHERE student_id = ?", (student_id,))
    conn.commit()
    conn.close()
    # --- CHANGED (assistant) START ---
    try:
        avatar_url = get_avatar_url_for_student(student_id)
    except Exception:
        avatar_url = "/avatars/default.jpg"
    asyncio.create_task(manager.broadcast(json.dumps({"type":"presence","payload":{"student_id": student_id, "status": status, "timestamp": datetime.now().isoformat(), "avatarUrl": avatar_url}})))
    # --- CHANGED (assistant) END ---
    return {"success": True, "student_id": student_id, "student_name": name, "status": status}

# ------------------------
# WebSocket endpoint
# ------------------------
@app.websocket("/ws/events")
async def ws_events(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        # initial connect
        await websocket.send_text(json.dumps({"type":"info","message":"ws_connected"}))
        while True:
            try:
                raw = await websocket.receive_text()
            except WebSocketDisconnect:
                manager.disconnect(websocket)
                break
            except Exception as e:
                print("[WARN] ws receive_text error:", e)
                await asyncio.sleep(0.1)
                continue

            # Try parse JSON safely
            try:
                msg = json.loads(raw)
            except Exception:
                # If client sends plain text ping, acknowledge
                await websocket.send_text(json.dumps({"type":"ack","message":"ok"}))
                continue

            # Keep old behaviour for ping/ack
            if msg.get("type") == "ping":
                await websocket.send_text(json.dumps({"type":"ack","message":"ok"}))
                continue

            # If client sent base64 image in { "img": "<base64>" }
            if "img" in msg:
                b64 = msg.get("img") or ""
                # if client accidentally sent a full data URL, strip header
                if b64.startswith("data:") and "," in b64:
                    b64 = b64.split(",", 1)[1]

                try:
                    img_bytes = base64.b64decode(b64)
                except Exception as e:
                    await websocket.send_text(json.dumps({"type":"error", "message": "invalid_base64"}))
                    continue

                # Write debug file so you can open it on server
                try:
                    with open(str(BASE_DIR / "debug_incoming.jpg"), "wb") as f:
                        f.write(img_bytes)
                except Exception as e:
                    print("[WARN] could not write debug_incoming.jpg", e)

                # compute encoding
                enc = encoding_from_bytes(img_bytes)
                if enc is None:
                    await websocket.send_text(json.dumps({"type":"error", "message":"no_face_detected_or_decode_failed"}))
                    continue

                # If no known encodings loaded:
                if not known_encodings:
                    await websocket.send_text(json.dumps({"type":"error", "message":"no_known_faces_loaded"}))
                    continue

                # compare distances
                try:
                    dists = face_recognition.face_distance(known_encodings, enc)
                except Exception as e:
                    print("[ERROR] face_distance failed:", e)
                    await websocket.send_text(json.dumps({"type":"error", "message":"matching_failed"}))
                    continue

                best_idx = int(np.argmin(dists))
                best_dist = float(dists[best_idx]) if len(dists) > 0 else math.inf
                confidence = max(0.0, 1.0 - best_dist)

                # tune tolerance as needed
                TOL = 0.48
                if best_dist <= TOL:
                    student_id = known_names[best_idx]
                    resp = {"type":"recognized", "student_id": student_id, "confidence": confidence}
                    # broadcast presence event to other WS clients
                    # --- CHANGED (assistant) START ---
                    try:
                        avatar_url = get_avatar_url_for_student(student_id)
                    except Exception:
                        avatar_url = "/avatars/default.jpg"
                    asyncio.create_task(manager.broadcast(json.dumps({"type":"presence","payload":{"student_id": student_id, "status":"Present","timestamp": datetime.now().isoformat(), "confidence": confidence, "avatarUrl": avatar_url}})))
                    # --- CHANGED (assistant) END ---
                else:
                    resp = {"type":"unknown", "best_distance": best_dist, "confidence": confidence}

                await websocket.send_text(json.dumps(resp))
                continue

            # Unknown message type -> ack
            await websocket.send_text(json.dumps({"type":"ack","message":"ok"}))

    except Exception as e:
        print("[ERROR] ws_events outer", e)
        manager.disconnect(websocket)

# ------------------------
# Helper: attendance %
# ------------------------
def calculate_attendance_percentage(student_id: str) -> int:
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
          SELECT COUNT(DISTINCT DATE(ts)) as present_days
          FROM attendance_events
          WHERE student_id = ?
          AND type = 'checkin'
          AND ts >= datetime('now', '-30 days')
        """, (student_id,))
        pd = cur.fetchone()[0] or 0
        conn.close()
        return min(int((pd / 30) * 100), 100)
    except:
        return 85

# ------------------------
# Startup
# ------------------------
@app.on_event("startup")
async def startup():
    print("[INFO] Starting PresenceAI backend...")
    print("[INFO] BASE_DIR:", BASE_DIR)
    print("[INFO] avatars dir:", AVATARS_DIR.resolve())
    try:
        print("[INFO] avatars contents:", [p.name for p in AVATARS_DIR.iterdir()])
    except Exception as e:
        print("[WARN] avatars listing failed:", e)

    init_db()
    load_known_faces()
    print(f"[INFO] known faces loaded: {len(known_names)}")

# ------------------------
# Serve static avatar files (simple)
# ------------------------
@app.get("/avatars/{filename}")
async def avatar_file(filename: str):
    # prevent path traversal
    filename = os.path.basename(filename)
    path = AVATARS_DIR / filename
    if path.exists() and path.is_file():
        return FileResponse(str(path))
    default = AVATARS_DIR / "default.jpg"
    if default.exists() and default.is_file():
        return FileResponse(str(default))
    # fallback: return 404 with JSON so frontend can load placeholder
    raise HTTPException(status_code=404, detail="Avatar not found")

# ------------------------
# Run
# ------------------------
if __name__ == "__main__":
    init_db()
    load_known_faces()
    print("Run: uvicorn main:app --reload --host 0.0.0.0 --port 8000")
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
